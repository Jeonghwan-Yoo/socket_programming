07-1 TCP 기반의 Half-close
TCP에서는 연결과정보다 중요한 것이 종료과정.
연결과정에서는 큰 변수가 발생하지 않지만 종료 과정에서는 예상치 못한 일이 발생할 수 있기 때문.
따라서 종료과정은 명확해야 한다.

일방적인 연결종료의 문제점
리눅스의 close와 윈도우의 closesocket은 완전종료를 의미한다.
완전종료라는 것은 데이터를 전송하는 것과 수신하는 것 조차 불가능한 상황.
그래서 한쪽에서의 일방적인 close나 closesocket은 경우에 따라서 우아해 보이지 않을 수 있다.
호스트 A가 마지막 데이터를 전송하고 나서 close 함수의 호출을 통해 연결을 종료한다.
그 이후부터 호스트 A는 호스트 B가 전송하는 데이터를 수신하지 못한다.
데이터 수신과 관련된 함수의 호출 자체가 불가능하다.
호스트 B가 전송한 데이터는 중요해도 소멸되고 만다.
이러한 문제의 해결을 위해 데이터의 송수신에 사용되는 스트림의 일부만 종료(Half-close)하는 방법이 제공.
일부를 종료한다는 것은 전송은 가능하지만 수신은 불가능한 상황이나 수신은 가능하지만 전송은 불가능한 상황을 말한다.
스트림의 반만 닫는 것이다.

소켓과 Stream
소켓을 통해 두 호스트가 연결되면, 데이터의 송수신이 가능한 상태.
스트림이 형성된 상태로 두 소켓이 연결되어서 데이터의 송수신이 가능한 상태를 일종의 스트림으로 보는 것.
소켓의 스트림 역시 한쪽 방향으로만 데이터의 이동이 가능하기 때문에 양방향 통신을 위해서는 두 개의 스트림이 필요하다.
                               입출력 스트림 1
호스트A <-read()-입력버퍼(데이터) ----------- 출력버퍼(데이터)<-write()<-호스트B
       ->write()-출력버퍼(데이터) ----------- 입력버퍼(데이터)->read()->
                               입출력 스트림 2
소켓이 연결되면, 각 호스트 별로 입력 스트림과 출력 스트림이 형성된다.
한 호스트의 입력 스트림은 다른 호스트의 출력 스트림으로 이어지고, 한 호스트의 출력 스트림은 다른 호스트의 입력 스트림으로 이어진다.
우아한 종료는 이 중 하나의 스트림만 끊는 것.
리눅스의 close와 윈도우의 closesocket은 두 스트림을 동시에 끊어버린다.

우아한 종료를 위한 shutdown 함수
#include <sys/socket.h>
int shutdown(int sock, int howto); // 성공 시 0, 실패 시 -1 반환
sock:종료할 소켓의 파일 디스크립터 전달.
howto:종료방법에 대한 정보 전달.
두 번째 매개변수의 인자의 종류
SHUT_RD:입력 스트림 종료
SHUT_WR:출력 스트림 종료
SHUT_RDWR:입출력 스트림 종료
SHUT_RD가 전달되면 입력 스트림이 종료되어 더 이상 데이터를 수신할 수 없는 상태.
입력버퍼에 전달되더라도 지워져 버릴 뿐만 아니라 입력 관련 함수의 호출도 허용이 안된다.
SHUT_WR가 전달되면 출력 스트림이 종료되어 더 이상의 데이터 전송이 불가능.
출력 버퍼에 아직 전송되지 못한 상태로 남아 있는 데이터가 존재하면 해당 데이터는 목적지로 전송.
SHUT_RDWR는 각각 두 번 호출한 것과 같다.

Half-close가 필요한 이유
충분한 시간적 여유를 둬서 송수신을 완료하고 난 다응에 연결을 종료해도 되는 상황은 필요 없다.
파일을 전송하는 서버는 단순히 파일 데이터를 연속해서 전송하면 되지만, 클라이언트는 언제까지 데이터를 수신해야할 지 모른다.
계속해서 입력함수를 호출하면 블로킹 상태(호출된 함수가 반환하지 않는 상태)에 빠질 수 있기 때문이다.
파일의 끝을 의미하는 문자도 파일에 존재할 수 있기에 완전하지 않는다.
이러한 문제의 해결을 위해서는 서버는 파일의 전송이 끝났음을 알리는 목적으로 EOF를 마지막에 전송해야 한다.
클라이언트는 EOF의 수신을 함수의 반환 값을 통해서 확인이 가능하기 때문에 파일에 저장된 데이터와 중복될 일도 없다.
서버가 EOF를 전달하는 방법은 출력 스트림을 종료하면 상대 호스트로 EOF가 전송됩니다.
close함수호출하면 데이터를 수신하지 못하는 문제가 있다.
shutdown 함수호출을 통해서 서버의 출력 스트림만 Half-close하면 EOF도 전송되고 입력 스트림은 여전히 살아있어서 데이터의 수신도 가능하다.

Half-close 기반의 파일전송 프로그램
Server<----------Client:연결요청
Server---------->Client:파일 데이터
Server---------->Client:EOF(Half-close)
Server<----------Client:데이터

file_server.c
file_client.c

07-2 윈도우 기반으로 구현하기
#include <winsock2.h>
int shudown(SOCKET sock, int howto); // 성공 시 0, SOCKET_ERROR 반환
sock:종료할 소켓의 핸들.
howto:종료방법에 대한 정보 전달.
두 번째 인자
SD_RECEIVE:입력 스트림 종료
SD_SEND:출력 스트림 종료
SD_BOTH:입출력 스트림 종료
선언된 상수의 값은 리눅스와 같다.
SD_RECEIVE, SHUT_RD는 0, SD_SEND, SHUT_WR은 1, SD_BOTH, SHUT_RDWR은 2로 선언.
file_server_win.c
file_client_win.c

