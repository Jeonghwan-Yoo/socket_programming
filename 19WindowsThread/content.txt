19-1 Kernel Objects
커널 오브젝트란 무엇인가?
운영체제 리소스의 대부분은 프로그래머의 요청에 의해서 생성되며, 요청의 방식(함수)도 제각각이다.
그래도 윈도우 운영체제가 생성해서 관리하는 리소스들이라는 공통점.
관리의 방식 역시 리소스의 종류에 따라서 차이가 있다.
파일이라면 파일과 관련된 데이터의 입출력 위치, 파일의 오픈모드(read or write) 등이 등록 및 갱신되어야 하며,
쓰레드라면 쓰레드의 ID, 그리고 쓰레드가 속한 프로세스의 정보가 등록 및 유지되어야 한다.
운영체제에 의해서 생성되는 리소스들은 관리를 목적으로 정보를 기록하기 위해 내부적으로 데이터 블록을 생성한다. (구조체)
리소스마다 유지해야 하는 정보가 다르니, 데이터 블록의 형태는 리소스마다 차이가 있다.
이 데이터 블록을 가리켜 커널 오브젝트라 한다.
윈도우 상에서 파일을 생성하면 운영체제는 파일의 관리를 위해서 하나의 데이터 블록을 생성한다. 그리고 이것이 커널 오브젝트이다.
윈도우에서는 운영체제의 리소스에 해당하는 프로세스, 쓰레드 그리고 쓰레드의 동기화에 사용되는 세마포어를 생성하더라도 각각의 관리를 위한 커널 오브젝트를 생성한다.

커널 오브젝트의 소유자는 운영체제이다.
쓰레드, 파일 등의 생성요청이 프로세스 내에서 이뤄지긴 하지만 소유자는 커널(운영체제)이다.
이 뜻은 커널 오브젝트의 생성, 관리 그리고 소멸시점을 결정하는 것까지 모두 운영체제의 몫이다.
커널 오브젝트는 생성의 주체도 소유의 주체도 운영체제인 데이터 블록이다.

19-2 윈도우 기반의 쓰레드 생성
프로세스와 쓰레드의 관계
main 함수의 호출주체는 쓰레드이다.
유닉스 계열의 운영체제에서는 프로세스인적도 있었다.
운영체제 레벨에서 쓰레드를 지원하지 않아서 쓰레드의 생성을 위해서 별도의 라이브러리를 활용하는 경우가 많았기 때문.
운영체제는 쓰레드의 존재조차도 인식하지 못했고, 프로세스가 실행의 실질적인 최소단위였다.
그래도 쓰레드가 필요한 프로그래머들은 별도의 라이브러리를 이용해서 프로세스의 실행시간을 나누는 방식으로 쓰레드를 생성하였다.
하지만 응용 프로그램영역에서 만든 쓰레드이기 때문에 운영체제 레벨에서 지원되는 쓰레드와는 차이가 많았다.
지금은 크고 작은 각종 운영체제들도 운영체제 레벨에서 쓰레드를 지원한다.
쓰레드를 별도로 생성하지 않는 프로그램(select 기반의 서버)를 가리켜 단일 쓰레드 모델의 프로그램이라고 한다.
쓰레드를 별도로 생성하는 방식의 프로그램은 멀티 쓰레드 모델의 프로그램이라고 한다.
프로세스는 쓰레드를 담는 바구니이고, 실질적인 실행의 주체는 쓰레드이다.

윈도우에서의 쓰레드 생성방법
쓰레드가 생성되고, 운영체제는 이의 관리를 위해서 커널 오브젝트도 함께 생성한다.
마지막으로 이 커널 오브젝트의 구분자 역할을 하는, 정수로 표현되는 Handle을 반환한다.
#include <windows.h>
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId,
); // 성공 시 쓰레드 핸들, 실패 시 NULL 반환
lpThreadAttibutes:쓰레드의 보안관련 정보전달, 디폴트 보안설정을 위해서 NULL 전달
dwStackSize:쓰레드에게 할당할 스택의 크기를 전달, 0전달하면 디폴트 크기의 스택 생성.
lpStartAddress:쓰레드의 main함수정보 전달.
lpParameter:쓰레드의 main 함수호출 시 전달할 인자정보 전달.
dwCreationFlags:쓰레드 생성 이후의 행동을 결정, 0을 전달하면 생성과 동시에 실행 가능한 상태가 된다.
lpThreadId:쓰레드 ID의 저장을 위한 변수의 주소 값 전달.
신경쓸 것은 lpStartAddress, lpParameter이고, 나머지는 0이나 NULL을 전달.

윈도우 쓰레드의 소멸시점
윈도우 쓰레드의 소멸시점은 쓰레드에 의해서 처음 호출된, 쓰레드 main 함수가 반환하는 시점이다. (리눅스와 다르다)
쓰레드의 종료를 유도하는 방법이 있지만 가장 좋은 방법은 쓰레드의 main 함수를 종료(반환)하는 것.

멀티 쓰레드 기반의 프로그램 작성을 위한 환경설정
VC++ 상에서는 C/C++ Runtime Library(CRT)라는 것을 지정해줘야 한다.
C/C++ 표준함수의 호출에 필요한 라이브러리이다.
과거 VC++ 6.0 버전에서는 단일 쓰레드 모델만 지원하는(단일 쓰레드 프로그램에서만 제대로 동작하는) 라이브러리가 포함되어 있었고,
기본적으로 선택되어 있었기 때문에 라이브러리의 변경과정을 거쳐야 했다.
지금은 멀티 쓰레드 모델을 지원하는 라이브러리만 존재하니, 별도의 환경설정 과정을 거칠 필요가 없다.
프로젝트 -> 속성이나 ALT + F7을 입력해서 런타임 라이브러리 관련 페이지에서 런타임 라이브러리부분을 보면
선택가능한 네 가지 라이브러리 모두 멀티 쓰레드와 관련이 있다.
Use run-time library를 Multithread DLL로 변경하면 된다.

쓰레드에 안전한 C 표준함수의 호출을 위한 쓰레드 생성
CreateThread 함수호출을 통해서 생성되는 쓰레드는 C/C++ 표준함수에 대해서 안정적으로 동작하지 않는다.
#include <process.h>
uintptr_t _beginthreadex {
    void *security,
    unsigned stack_size,
    unsigned (*start_address)(void*),
    void *arglist,
    unsigned initflag,
    unsigned *thrdaddr
}; // 성공 시 쓰레드 핸들, 실패 시 0 반환
이름이랑 선언된 매개변수의 자료형에 조금 차이가 있다.
uintptr_t는 64비트로 표현되는 unsigned 정수 자료형이다.

_beginthreadex 함수 이전에 정의된 _beginthread 함수
_beginthread는 쓰레드 생성시 반환되는 핸들을 무효화시켜서 커널 오브젝트에 접근할 수 있는 방법을 막아버리는 문제점.

thread1_win.c
main 함수의 반환으로 인해 프로세스가 종료되면, 그 안에 담겨 있는 모든 쓰레드들도 함께 종료된다.
main 함수의 반환 이후에 프로세스가 완전히 소멸되기까지의 시간 사이에 출력된 문장도 있다.

핸들, 커널 오브젝트, 그리고 ID의 관계
쓰레드도 운영체제에 의해서 관리되는 리소스이기 때문에 커널 오브젝트의 생성을 동반한다.
이 커널 오브젝트를 참조할 수 있도록 핸들이 반환된다.
핸들이 가리키는 쓰레드가 종료될 때까지 대기하도록 요청할 수 있다.
핸들을 통해서 커널 오브젝트의 구분이 가능하고, 커널 오브젝트를 통해서 쓰레드의 구분이 가능하기 때문에, 결국 쓰레드의 핸들은 쓰레드를 구분하는 용도로 사용된다.
_beginthreadex 함수의 마지막 인자를 통해서 쓰레드의 ID를 얻게 된다.
핸들의 정수 같은 프로세스가 달라지면 중복될 수 있다. 하지만 쓰레드의 ID는 프로세스의 영역을 넘어서서 중복되지 않는다.
쓰레드의 ID는 운영체제가 생성하는 모든 쓰레드 각각을 구분하는 용도로 사용된다.

19-3 커널 오브젝트의 두 가지 상태
커널 오브젝트에는 해당 리소스의 성격에 따라서 많은 정보가 담긴다.
그 중에서도 프로그램의 구현에 있어서 특히 더 관심을 두어야 하는 정보에 대해 state를 부여한다.
쓰레드의 커널 오브젝트에 있어서의 큰 관심사는 종료여부이다.
종료된 사태를 가리켜 signaled 상태라 하고, 종료되지 않은 상태를 가리켜 non-signaled 상태라 한다.

커널 오브젝트의 상태, 그리고 상태의 확인
운영체제는 이러한 관심사에 대한 정보를 커널 오브젝트에 기록해 둔다.
운영체제는 프로세스나 쓰레드가 종료되면 해당 커널 오브젝트를 signaled 상태로 변경해 놓는다.
프로세스와 쓰레드의 커널 오브젝트 상태가 초기에는 non-signaled 상태이다.
상태는 boolean형 변수 하나로 표현이 된다.
커널 오브젝트는 boolean형 변수 하나를 지니고 있으면서, 이의 초기값을 FALSE로 두고, 이 상태를 non-signaled라고 하는 것.
약속된 상황이 발생하면(이벤트가 발생하면) 이 값을 TRUE로 두고, signaled라고 하는 것.
커널 오브젝트의 성격에 따라서 signaled 상태가 되는 상황이 다르다.
정상적인 실행을 위해 커널 오브젝트 상태를 질문해야 한다.

WaitForSingleObject & WaitForMultipleObjects
WaitForSingleObject는 하나의 커널 오브젝트에 대해서 signaled 상태인지를 확인하기 위해서 호출하는 함수.
#include <windows.h>
DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds); // 성공 시 이벤트 정보, 실패 시 WAiT_FAILED 반환
hHandle:상태확인의 대상이 되는 커널 오브젝트의 핸들을 전달.
dwMilliseconds:1/1000초 단위로 타임아웃을 지정, 인자로 INFINITE 전달 시, 커널 오브젝트가 signaled 상태가 되기 전에는 반환하지 않는다.
반환 값:signaled 상태로 인한 반환 시, WAIT_OBJECT_0 반환, 타임아웃으로 인한 반환 시 WAIT_TIMEOUT 반환.
이벤트 발생에 의해서(signaled 상태가 되어서) 반환되면, 해당 커널 오브젝트를 다시 non-signaled 상태로 되돌리기도 한다.
다시 non-signaled 상태가 되는 커널 오브젝트를 auto-reset 모드 커널 오브젝트라 하고, 자동으로 non-signaled 상태가 되지 않는 커널을 가리켜 manual-reset 모드 커널 오브젝트라 한다.
다음 함수는 둘 이상의 커널 오브젝트를 대상으로 상태를 확인하는 경우에 호출하는 함수.
#include <windows.h>
DWORD WaitForMultipleObject(DWORD nCount, const HANDLE* lpHandles, BOOL bWaitAll, DWORD dwMilliseconds); // 성공 시 이벤트 정보, 실패 시 WAIT_FAILED 반환
nCount:검사할 커널 오브젝트의 수 전달.
lpHandles:핸들정보를 담고 있는 배열의 주소 값 전달.
bWaitAll:TRUE전달 시, 모든 검사대상이 signaled 상태가 되어야 반환. FALSE로 전달 시, 검사대상 중 하나라고 signaled 상태가 되면 반환.
deMilliseconds:1/1000초 단위로 타임아웃 지정, 인자로 INFINITE 전달 시, 커널 오브젝트가 signaled 상태가 되기 전에는 반환하지 않는다.
thread2_win.c

WaitForSingleObjec & WaitForMultipleObjects
윈도우 기반에서 임계영역 관련 문제를 확인.
thread3_win.c
정상적인 실행결과는 확인할 수 없고 실행결과도 매번 다르다.