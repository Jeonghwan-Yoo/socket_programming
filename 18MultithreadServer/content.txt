웹의 발전은 유닉스 게열의 운영체제에서도 쓰레드의 중요성을 부각시켰다.
웹 기반의 서버에서는 프로토콜의 특성상 둘 이상의 클라이언트에게 동시에 서비스를 제공해야 하는 경우가 많다.
상대적으로 프로세스보다 효율적인 쓰레드를 서버구현에 적용한다.

18-1 쓰레드의 이론적 이해
쓰레드의 등장 배경
프로세스의 생성은 select나 epoll에 비해서 확실히 구분되는 장점이 있다.
프로세스의 생성(복사) 작업자체가 운영체제 차원에서 상당히 부담되는 작업이다.
뿐만 아니라, 프로세스마다 완전히 독립된 메모리 공간을 유지하기 때문에 프로세스 사이에서 메시지를 주고받아야 하는 경우에는 그만큼 구현의 어려움.
1. 프로세스 생성이라는 부담스러운 작업과정을 거친다.
2. 두 프로세스 사이에서의 데이터 교환을 위해서는 별도의 IPC 기법을 적용해야 한다.
3. 초당 적게는 수십 번에서 많게는 수천 번까지 일어나는 Context Switching에 따른 부담은 프로세스 생성방식의 가장 큰 부담.
실행중인 둘 이상의 프로세스들이 CPU의 할당시간을 매우 작은 크기로 쪼개서 서로 나눈다.
그런데 CPU의 할당시간을 나누기 위해서는 컨텍스트 스위칭이라는 과정을 거쳐야 한다.
프로그램의 실행을 위해서는 해당 프로세스의 정보가 메인 메모리에 올라와야 한다.
현재 실행중인 A 프로세스의 뒤를 이어서 B 프로세스를 실행시키려면 A 프로세스 관련 데이터를 메인 메모리에서 내리고 B 프로세스 관련 데이터를 메인 메모리로 이동시켜야 한다.
이것이 컨텍스트 스위칭이다.
이 때 A 프로세스 관련 데이터는 하드디스크로 이동하기 때문에 컨텍스트 스위칭에는 오랜 시간이 걸리고, 빨리 진행한다하더라도 한계가 있다.

컨텍스트 스위칭
CPU 내부에 존재하는 레지스터 중심으로 설명이 진행되어야 한다.

Thread는 멀티프로세스의 여러 가지 단점을 최소화하기 위해서 설계된 일종의 경량화된 프로세스이다.
1. 쓰레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠르다.
2. 쓰레드 사이에서의 데이터 교환에는 특별한 기법이 필요치 않다.

쓰레드와 프로세스의 차이점
둘 이상의 실행흐름을 갖기 위해서 프로세스가 유지하고 있는 메모리 영역을 통째로 복사한다는 것은 부담스럽다.
프로세스의 메모리 구조는 전역변수가 할당되는 데이터 영역, malloc 함수 등에 의해 동적 할당이 이뤄지는 Heap, 함수의 실행에 사용되는 Stack으로 이뤄진다.
그런데 프로세스들은 이를 완전히 별도로 유지한다.
|Process A|  |Process B|  |Process C|
|데이터   |  |데이터    |  |데이터   |
|힙       |  |힙       |   |힙      |
|스택     |  |스택     |   |스택     |
그런데 둘 이상의 실행흐름을 갖는 것이 목적이라면, 완전히 메모리 구조를 분리시킬 것이 아니라, 스택 영역만을 분리시킴으로써 장점을 얻을 수 있다.
1. 컨텍스트 스위칭 시 데이터 영역과 힙은 올리고 내릴 필요가 없다.
2. 데이터 영역과 힙을 이용해서 데이터를 교환할 수 있다.
그래서 등장한 것이 쓰레드이며, 모든 쓰레드는 별도의 실행흐름을 유지하기 위해서 스택 영역만 독립적으로 유지한다.
Process
|Thread A|  |Thread B|  |Thread C|
|A 스택  |  |B 스택  |   |C 스택  |
|        공유 데이터 영역         |
|          공유 힙 영역           |
데이터 영역과 힙 영역을 공유하는 구조로 쓰레드는 설계되어 있다.
이를 위해 쓰레드는 프로세스 내에서 생성 및 실행되는 구조로 완성.
프로세스:운영체제 관점에서 별도의 실행흐름을 구성하는 단위
쓰레드:프로세스 관점에서 별도의 실행흐름을 구성하는 단위
Operating System
Process A  Process B  ...
Thread A1  Thread B1
Thread A2  Thread B2
...

18-2 쓰레드의 생성 및 실행
POSIX란 Potable Operating System Interface for Computer Environment로 UNIX 계열 운영체제간에 이식성을 높이기 위한 표준 API 규격을 뜻한다.
쓰레드의 생성방법은 PISIX에 정의된 표준을 근거로 한다.

쓰레드의 생성과 실행흐름의 구성
쓰레드는 별도의 실행흐름을 갖기 때문에 쓰레드만의 main 함수를 별도로 정의해야 한다.
그리고 이 함수를 시작으로 별도의 실행흐름을 형성해 줄 것을 운영체제에게 요청해야 한다.
#include <pthread.h>
int pthread_create (
    pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start)routine)(void*), void *restrict arg
); // 성공 시 0, 실패 시 0 이외의 값 반환
thread:생성할 쓰레드의 ID 저장을 위한 변수의 주소 값 전달, 쓰레드는 프로세스와 마찬가지로 쓰레드의 구분을 위한 ID가 부여된다.
attr:쓰레드에 부여할 특성 정보의 전달을 위한 매개변수, NULL 전달 시 기본적인 특성의 쓰레드가 생성된다.
start_routine:쓰레드의 main 함수 역할을 하는, 별도 실행흐름의 시작이 되는 함수의 주소값(함수 포인터) 전달.
arg:세 번째 인자를 통해 등록된 함수가 호출될 때 전달할 인자의 정보를 담고 있는 변수의 주소 값 전달.
키워드 restrict와 함수 포이터 관련 문법을 잘 알고 있어야 한다.
thread1.c
쓰레드 관련코드는 컴파일 시 -lpthread옵션을 추가해서 쓰레드 라이브러리의 링크를 별도로 지시해야 한다.
Process
   ├────────────────→ thread
   │pthread_create()    │
   │                    │
   │sleep()             │
   │                    │
프로세스 종료      쓰레드 함께 종료
sleep 함수의 호출을 통해서 쓰레드의 실행을 관리한다는 것은 프로그램의 흐름을 예측한다는 것인데 불가능하다.

다음 함수는 sleep 보다 문제를 쉽고 효율적으로 해결할 수 있다.
또한 쓰레드의 ID가 어떠한 경우에 사용되는지도 함께 확인할 수 있다.
#include <pthread.h>
int pthread_join(pthread_t thread, void **status); // 성공 시 0, 실패 시 0 이외의 값 반환
thread:이 매개변수에 전달되는 ID의 쓰레드가 종료될 때까지 함수는 반환하지 않는다.
status:쓰레드의 main함수가 반환하는 값이 저장될 포인터 변수의 주소 값을 전달한다.
첫 번째 인자로 전달되는 ID의 쓰레드가 종료될 때까지, 이 함수를 호출한 프로세스(또는 쓰레드)를 대기상태에 둔다.
쓰레드의 main함수가 반환하는 값까지 얻을 수 있으니 유용하다.
thread2.c
실행이 일시적으로 정지되었다가 쓰레드가 종료되면서(쓰레드의 main 함수가 반환하면서) 다시 실행이 이어진다.
Process
   ├────────────────→ thread
   │pthread_create()    │
   │                    │
   └────────────────→   │
    pthread_join()      │
   ┌  ←─────────────────┘쓰레드 종료
   │             return
프로세스 종료     

임계영역 내에서 호출이 가능한 함수
쓰레드를 하나 생성하건, 둘을 생성하건 방법에 있어서 차이를 보이진 않는다.
그러나 쓰레드의 실향과 관련해서 주의해야 할 사실이 있다.
둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 함수가 있다.
이는 함수 내에 Critical Sectoin이라 불리고, 둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 문장이 하나 이상 존재하는 함수이다.
임계영역의 문제와 관련해서 함수는 Thread-safe function 이거나 Thread-unsafe function이다.
쓰레드에 안전한 함수는 둘 이상의 쓰레드에 의해서 동시에 호출 및 실행되어도 문제를 일으키지 않는 함수이다.
쓰레드에 불안전한 함수는 동시호출 시 문제가 발생할 수 있는 함수이다.
이것이 임계영역의 유무를 뜻하는 것은 아니다.
쓰레드에 안전한 함수도 임계영역이 존재할 수 있다.
다만 이 영역을 둘 이상의 쓰레드가 동시에 접근해도 문제를 일으키지 않도록 적절한 조치가 이뤄져 있어서 쓰레드에 안전한 함수로 구분.
기본적으로 제공되는 대부분의 표준함수들은 쓰레드에 안전하다.
그리고 쓰레드에 안전한 함수와 불안전한 함수의 구분을 우리가 직접 할 필요가 없다.
왜냐하면 쓰레드에 불안전한 함수가 정의되어 있는 경우, 같은 기능을 갖는 쓰레드에 안전한 함수가 정의되어 있기 때문이다.
struct hostent* gethostbyname(const char *hostname); 은 쓰레드에 안전하지 않다.
동일한 기능을 제공하면서 쓰레드에 안전한 함수가 정의되어 있다.
struct hostent *gethostbyname_r(const char *name, struct hostent *result, char *buffer, int buflen, int *h_errnop);
일반적으로 쓰레드에 안전한 형태로 재구현된 함수의 이름에는 _r이 붙는다.(윈도우는 다르다)
둘 이상의 쓰레드가 동시에 접근 가능한 코드블록에서는 _r을 호출해야해서 귀찮을 수 있다.
다음을 통해 자동화할 수 있다.
헤더파일 선언 이전에 매크로 _REENTRANT를 정의한다.
매크로 정의를 위해서 소스코드에 #define 문장을 추가할 필요도 없다.
컴파일 시 -D_REENTRANㅅ의 옵션을 추가하는 방식으로 매크로를 정의할 수 있기 때문.
# gcc -D_REENTRANT mythread.c -o mythead -lpthread

Worker 쓰레드 모델
쓰레드에게 각각의 역할을 주고 합치는 worker thread 모델.
쓰레드가 main함수가 관리하는 Worker의 형태를 띤다.
                        Process
                           ├─────────────────→ thread
thread  ←──────────────────┤ pthread_create()    │
  │       pthread_create() └─────────────────→   │
  │                          pthread_join()      │
  │                        ┌  ←──────────────────┘쓰레드 종료
  │     ←──────────────────┘            return 1~5
  │          pthread_join()
  └─────────────────────→  ┐
  return 6~10              │1~10
쓰레드 종료            프로세스 종료
thread3.c
두 쓰레드가 하나의 전역변수 sum에 직접 접근한다.
전역변수가 저장되는 데이터 영역을 두 쓰레드가 함께 공유하기 때문에 가능하다.
thread4.c
실행결과는 0이 아니고, 매번 결과도 달라진다.

18-3 쓰레드의 문제점과 Critical Section
하나의 변수에 둘 이상의 쓰레드가 동시에 접근하는 것이 문제
전역변수 num에 둘 이상의 쓰레드가 동시에 접근하고 있다.
어떠한 메모리 공간이라도 동시에 접근을 하면 문제가 발생할 수 있다.
물론 쓰레드들은 CPU의 할당시간을 나눠서 실행하게 된다.
        num:99
thread1       thread2
값의 증가는 CPU를 통한 연산이 필요한 작업이다.
        num:99 -> 100
    99↙↗100
thread1       thread2
그냥 변수 num에 저장된 값이, 변수 num에 저장된 상태로 증가하지는 않는다.
이 변수에 저장된 값은 thread1에 의해서 원 참조가 된다.
thread1은 이 값을 CPU에 전달해서 1이 증가된 값 100을 얻는다.
마지막으로 연산이 완료된 값을 변수 num에 다시 저장한다.
이렇게 해서 변수 num에 100이 저장되는 것이다.
        num:100 -> 101
         101↖↘100
thread1       thread2
이렇게 해서 변수 num에는 101이 저장된다.
이는 매우 이상적인 상황이다.
thread1이 변수 num에 저장된 값을 완전히 증가시키기 전에라도 얼마든지 thread2로 CPU의 실행이 넘어갈 수 있기 때문.
        num:99
    99↙
thread1       thread2
thread1이 변수 num에 저장된 값을 참조해서 1 증가시키는 것까지 완료한 상황.
변수 num에는 아직 증가된 값을 저장하지 않았다.
이제 100이라는 값을 변수 num에 저장ㅇ해야 하는데, 진행되기 전에 thread2로 실행의 순서가 넘어가 버렸다.
thread2는 증가연산을 완전히 완료해서, 증가된 값을 변수 num에 저장했다고 가정.
        num:99 -> 100
         100↖↘99
thread1       thread2
num에 저장된 값이 thread1에 의해서 100으로 증가된 상태가 아니기 때문에 thread2가 참조한 변수 num의 값은 99이다.
thread2에 의해서 변수 num의 값은 100이 되었다.
thread1이 증가시킨 값을 변수 num에 저장하는 일만 남았다.
        num:100 -> 100
       ↗100
thread1       thread2
이미 100으로 증가된 변수 num에 다시 100을 저장하는 일이 발생했다.
이러한 문제를 막기 위해서 한 쓰레드가 변수 num에 접근해서 연산을 완료할 때까지, 다른 쓰레드 변수 num에 접근하지 못하도록 막아야 한다.
이것이 Synchronization.

임계영역은 어디?
함수 내에 둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 하나 이상의 문장으로 묶여있는 코드블록.
num은 문제를 일으키지도 않고, 동시에 실행되지도 않고, 메모리의 할당을 요구하는 변수의 선언일 뿐이다.
일반적으로 임계영역은 쓰레드에 의해서 실행되는 함수 내에 존재한다.
num += 1; num -= 1;
변수 num에 접근하는 두 문장이 임계영역에 해당한다.
이 두 문장은 둘 이상의 쓰레드에 의해서 동시에 실행되도록 구현되어 있는, 문제를 일으키는 직접적인 원인이 되기 때문이다.
1. 두 쓰레드가 동시에 thread_inc 함수를 실행하는 경우
2. 두 쓰레드가 동시에 thread_des 함수를 실행하는 경우
3. 두 쓰레드가 각각 thread_inc함수와 thread_des 함수를 동시에 실행하는 경우
이렇듯 임계영역은 서로 다른 두 문장이 각각 다른 쓰레드에 의해서 동시에 실행되는 상황에서도 만들어질 수 있다.
동일한 메모리 공간에 접근을 한다면 말이다.

18-4 쓰레드 동기화
이 해결책을 가리켜 쓰레드 Synchronization라 한다.

동기화의 두 가지 측면
쓰레드의 동기화는 쓰레드의 접근순서 때문에 발생하는 문제점의 해결책을 뜻한다.
동기화가 필요한 상황
1. 동일한 메모리 영역으로의 동시접근이 발생하는 상황
2. 동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야 하는 상황
예를 들어서 쓰레드 A는 메모리 공간에 값을 저장하는 역할을 담당하고, 쓰레드 B는 이 값을 가져가는 역할을 담당한다고 가정.
이러한 경우에는 쓰레드 A가 약속된 메모리 공간에 먼저 접근을 해서 값을 저장해야 한다.
혹시라도 쓰레드 B가 먼저 접근을 해서 값을 가져가면, 잘못된 결과로 이어질 수 있다.
이렇게 실행순서의 컨트롤이 필요한 상황에서도 동기화 기법이 활용된다.

Mutex
Mutual Exclusion의 줄임 말로써 쓰레드의 동시접근을 허용하지 않는다는 의미가 있다.
뮤텍스는 쓰레드의 동기접근에 대한 해결책으로 주로 사용된다.
현실세계에서의 임계영역은 화장실이다.
1. 화장실의 접근보호를 위해서 들어갈 때 문을 잠그고, 나올 때 문을 연다.
2. 화장실이 사용 중이라면, 밖에서 대기해야 한다.
3. 대기중인 사람이 둘 이상 될 수 있고, 이들은 대기순서에 따라서 화장실에 들어간다.
자물쇠 시스템이 쓰레드의 동기화에 필요하다.
뮤텍스는 매우 훌륭한 자물쇠 시스템이다.
#include <pthread.h>
int pthread_mutex_init(pthread_mutext_t *mutex, const pthread_mutexattr_r *attr); // 성공 시 0, 실패 시 0 이외의 값 반환
int pthread_mutex_destroy(pthread_mutex_t *mutex); // 성공 시 0, 실패 시 0 이외의 값 반환
mutex:뮤텍스 생성시에는 뮤텍스의 참조 값 저장을 위한 변수의 주소 값 전달. 그리고 뮤텍스 소멸 시에는 소멸하고자 하는 뮤텍스의 참조 값을 저장하고 있는 변수의 주소 값 전달.
attr:생성하는 뮤텍스의 특성정보를 담고 있는 변수의 주소 값 전달. 별도의 특성을 지정하지 않을 경우에는 NULL 전달.
자물쇠 시스템에 해당하는 뮤텍스의 생성을 위해서는 pthread_mutex_t형 변수가 하나 선언되어야 한다.
pthread_mutex_t mutex;
이 변수의 주소 값은 pthread_mutex_nit함수호출 시 인자로 전달되어서, 운영체제가 생성한 뮤텍스의 참조에 사용된다.
때문에 pthread_mutex_destroy 함수호출 시에도 인자로 사용되는 것.
뮤텍스 생성시 별도의 특성을 지정하지 않아서 두 번째 인자로 NULL을 전달하는 경우에는 매크로 PTHREAD_MUTEX_INITIALIZER을 이용해서 초기화하는 것도 가능.
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
매크로를 이용한 초기화는 오류발생에 대한 확인이 어려워 함수를 추천.

#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex); // 성공 시 0, 실패 시 0 이외의 값 반환
int pthread_mutex_unlock(pthread_mutex_t *mutex); // 성공 시 0, 실패 시 0 이외의 값 반환
임계영역에 들어가기에 앞서 호출하는 함수가 pthread_mutex_lock.
다른 쓰레드가 이미 임계영역을 실행하고 있는 상황이라면, 이 쓰레드가 pthread_mutex_unlock 함수를 호출하면서 임계영역을 빠져나갈 때까지 pthread_mutex_lock 함수는 반환하지 않는다.
다른 쓰레드가 임계영역을 빠져나갈 때까지 블로킹 상태에 놓이게 된다.
뮤텍스가 이미 생성된 상태에서는 임계영역을 보호하게 된다.
pthread_mutex_lock(&mutex);
// 임계영역의 시작
// 임계영역의 끝
pthread_mutex_unlock(&mutex);
임계영역의 시작과 끝을 감싸는 것.
임계영역에 대한 자물쇠 역할을 하면서 둘 이상의 쓰레드 접근을 허용하지 않게 된다.

임계영역을 빠져나가는 쓰레드가 unlock 함수를 호출하지 않는다면, 임계영역으로의 진입을 위해 lock 함수는 블로킹 상태에서 빠져나가지 못하게 되는 것을 Dead-lock.
이러한 상황이 발생하지 않도록 주의해야 한다.
mutex.c
하지만 뮤텍스의 lock, unlock 함수의 호출에는 생각보다 오랜시간이 걸린다.
뮤텍스의 lock, unlock 함수의 호출 수를 최대한으로 제한한다.
예제에서는 thread_des 함수는 thread_inc 함수보다 뮤텍스의 lock, unlock 함수를 4999999회 더 호출하는 구조다.
인간이 느낄 정도의 속도 차를 보인다.
쓰레드의 대기 시간이 문제가 되지 않는 상황이라면, 임계영역을 넓게 잡아주는 것이 좋다.
하지만 변수는 num의 값 증가가 50000000회 진행될 때까지 다른 쓰레드의 접근을 허용하지 않기 때문에 단점으로 작용할 수 있다.
정답은 없다.
임계영역을 넓게 잡느냐, 최대한 좁게 잡느냐는 프로그램의 성격에 따라 달리 결정할 요소다.

Semaphore
세마포어는 뮤텍스와 매우 유사.
0과 1만을 사용하는 바이너리 세마포어를 대상으로 쓰레드의 실행순서 컨트롤 중심의 동기화를 설명한다.
#include <semaphore.h>
int sem)init(sem_ *sem, int pshared, unsigned int value); // 성공 시 0, 실패 시 0 이외의 값 반환
int sem_destroy(sem_t *sem); // 성공 시 0, 실패 시 0 이외의 값 반환
sem:세마포어 생성시에는 세마포어의 참조 값 저장을 위한 변수의 주소 값 전달, 그리고 세마포어 소멸 시에는 소멸하고자 하는 세마포어의 참조 값을 저장하고 있는 변수의 주소 값 전달.
pshared:0이외의 값 전달 시, 둘 이상의 프로세스에 의해 접근 가능한 세마포어 생성, 0 전달 시 하나의 프로세스 내에서만 접근가능한 세마포어 생성.
value:생성되는 세마포어의 초기 값 지정.
#include <semaphore.h>
int sem_post(sem_t *sem); // 성공 시 0, 실패 시 0 이외의 값 반환
int sem_wait(sem_t *sem); // 성공 시 0, 실패 시 0 이외의 값 반환
sem:세마포어의 참조 값을 저장하고 있는 변수의 주소 값 전달, sem_post에 전달되면 세마포어의 값은 하나 증가, sem_wait에 전달되면 세마포어의 값은 하나 감소.
sem_init 함수가 호출되면 운영체제에 의해서 세마포어 오브젝트라는 것이 만들어 지는데, Semaphore Value 정수가 하나 기록된다.
이 값은 sem_post함수가 호출되면 1 증가하고, sem_wait 함수가 호출되면 1 감소한다.
세마포어 값은 0보다 작아질 수 없기 때문에 0에서 sem_wait함수를 호출하면, 호출한 쓰레드를 함수가 반환하지 않아서 블로킹 상태에 놓이게 된다.
다른 쓰레드가 sem_post함수를 호출하면 세마포어의 값이 1되자마자 0으로 감소시키면서 블로킹 상태에서 빠져나가게 된다.
sem_wait(&sem); // 세마포어 값을 0으로
// 임계영역의 시작
// 임계영역의 끝
sem_post(&sem); // 세마포어 값을 1로
sem_wait 함수를 호출하면서 임계영역에 진입한 쓰레드가 sem_post 함수를 호출하기 전까지는 다른 쓰레드에 의해서 임계영역의 진입이 허용되지 않는다.
세마포어 값이 0과 1을 오가는 구성을 바이너리 세마포어.
이번에는 동시접근 동기화가 아닌 접근순서의 동기화.
쓰레드 A가 프로그램 사용자로부터 값을 입력 받아서 전역변수 num에 저장을 하면, 쓰레드 B는 이 값을 누적해 나간다.
총 5회 진행, 완료되면 총 누적금액을 출력.
변수 num의 접근은 쓰레드 A, 쓰레드 B의 순으로 이뤄져야 한다.