웹의 발전은 유닉스 게열의 운영체제에서도 쓰레드의 중요성을 부각시켰다.
웹 기반의 서버에서는 프로토콜의 특성상 둘 이상의 클라이언트에게 동시에 서비스를 제공해야 하는 경우가 많다.
상대적으로 프로세스보다 효율적인 쓰레드를 서버구현에 적용한다.

18-1 쓰레드의 이론적 이해
쓰레드의 등장 배경
프로세스의 생성은 select나 epoll에 비해서 확실히 구분되는 장점이 있다.
프로세스의 생성(복사) 작업자체가 운영체제 차원에서 상당히 부담되는 작업이다.
뿐만 아니라, 프로세스마다 완전히 독립된 메모리 공간을 유지하기 때문에 프로세스 사이에서 메시지를 주고받아야 하는 경우에는 그만큼 구현의 어려움.
1. 프로세스 생성이라는 부담스러운 작업과정을 거친다.
2. 두 프로세스 사이에서의 데이터 교환을 위해서는 별도의 IPC 기법을 적용해야 한다.
3. 초당 적게는 수십 번에서 많게는 수천 번까지 일어나는 Context Switching에 따른 부담은 프로세스 생성방식의 가장 큰 부담.
실행중인 둘 이상의 프로세스들이 CPU의 할당시간을 매우 작은 크기로 쪼개서 서로 나눈다.
그런데 CPU의 할당시간을 나누기 위해서는 컨텍스트 스위칭이라는 과정을 거쳐야 한다.
프로그램의 실행을 위해서는 해당 프로세스의 정보가 메인 메모리에 올라와야 한다.
현재 실행중인 A 프로세스의 뒤를 이어서 B 프로세스를 실행시키려면 A 프로세스 관련 데이터를 메인 메모리에서 내리고 B 프로세스 관련 데이터를 메인 메모리로 이동시켜야 한다.
이것이 컨텍스트 스위칭이다.
이 때 A 프로세스 관련 데이터는 하드디스크로 이동하기 때문에 컨텍스트 스위칭에는 오랜 시간이 걸리고, 빨리 진행한다하더라도 한계가 있다.

컨텍스트 스위칭
CPU 내부에 존재하는 레지스터 중심으로 설명이 진행되어야 한다.

Thread는 멀티프로세스의 여러 가지 단점을 최소화하기 위해서 설계된 일종의 경량화된 프로세스이다.
1. 쓰레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠르다.
2. 쓰레드 사이에서의 데이터 교환에는 특별한 기법이 필요치 않다.

쓰레드와 프로세스의 차이점
둘 이상의 실행흐름을 갖기 위해서 프로세스가 유지하고 있는 메모리 영역을 통째로 복사한다는 것은 부담스럽다.
프로세스의 메모리 구조는 전역변수가 할당되는 데이터 영역, malloc 함수 등에 의해 동적 할당이 이뤄지는 Heap, 함수의 실행에 사용되는 Stack으로 이뤄진다.
그런데 프로세스들은 이를 완전히 별도로 유지한다.
|Process A|  |Process B|  |Process C|
|데이터   |  |데이터    |  |데이터   |
|힙       |  |힙       |   |힙      |
|스택     |  |스택     |   |스택     |
그런데 둘 이상의 실행흐름을 갖는 것이 목적이라면, 완전히 메모리 구조를 분리시킬 것이 아니라, 스택 영역만을 분리시킴으로써 장점을 얻을 수 있다.
1. 컨텍스트 스위칭 시 데이터 영역과 힙은 올리고 내릴 필요가 없다.
2. 데이터 영역과 힙을 이용해서 데이터를 교환할 수 있다.
그래서 등장한 것이 쓰레드이며, 모든 쓰레드는 별도의 실행흐름을 유지하기 위해서 스택 영역만 독립적으로 유지한다.
Process
|Thread A|  |Thread B|  |Thread C|
|A 스택  |  |B 스택  |   |C 스택  |
|        공유 데이터 영역         |
|          공유 힙 영역           |
데이터 영역과 힙 영역을 공유하는 구조로 쓰레드는 설계되어 있다.
이를 위해 쓰레드는 프로세스 내에서 생성 및 실행되는 구조로 완성.
프로세스:운영체제 관점에서 별도의 실행흐름을 구성하는 단위
쓰레드:프로세스 관점에서 별도의 실행흐름을 구성하는 단위
Operating System
Process A  Process B  ...
Thread A1  Thread B1
Thread A2  Thread B2
...

18-2 쓰레드의 생성 및 실행
POSIX란 Potable Operating System Interface for Computer Environment로 UNIX 계열 운영체제간에 이식성을 높이기 위한 표준 API 규격을 뜻한다.
쓰레드의 생성방법은 PISIX에 정의된 표준을 근거로 한다.

쓰레드의 생성과 실행흐름의 구성
쓰레드는 별도의 실행흐름을 갖기 때문에 쓰레드만의 main 함수를 별도로 정의해야 한다.
그리고 이 함수를 시작으로 별도의 실행흐름을 형성해 줄 것을 운영체제에게 요청해야 한다.
#include <pthread.h>
int pthread_create (
    pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start)routine)(void*), void *restrict arg
); // 성공 시 0, 실패 시 0 이외의 값 반환
thread:생성할 쓰레드의 ID 저장을 위한 변수의 주소 값 전달, 쓰레드는 프로세스와 마찬가지로 쓰레드의 구분을 위한 ID가 부여된다.
attr:쓰레드에 부여할 특성 정보의 전달을 위한 매개변수, NULL 전달 시 기본적인 특성의 쓰레드가 생성된다.
start_routine:쓰레드의 main 함수 역할을 하는, 별도 실행흐름의 시작이 되는 함수의 주소값(함수 포인터) 전달.
arg:세 번째 인자를 통해 등록된 함수가 호출될 때 전달할 인자의 정보를 담고 있는 변수의 주소 값 전달.
키워드 restrict와 함수 포이터 관련 문법을 잘 알고 있어야 한다.
thread1.c
쓰레드 관련코드는 컴파일 시 -lpthread옵션을 추가해서 쓰레드 라이브러리의 링크를 별도로 지시해야 한다.
Process
   ├────────────────→ thread
   │pthread_create()    │
   │                    │
   │sleep()             │
   │                    │
프로세스 종료      쓰레드 함께 종료
sleep 함수의 호출을 통해서 쓰레드의 실행을 관리한다는 것은 프로그램의 흐름을 예측한다는 것인데 불가능하다.

다음 함수는 sleep 보다 문제를 쉽고 효율적으로 해결할 수 있다.
또한 쓰레드의 ID가 어떠한 경우에 사용되는지도 함께 확인할 수 있다.
#include <pthread.h>
int pthread_join(pthread_t thread, void **status); // 성공 시 0, 실패 시 0 이외의 값 반환
thread:이 매개변수에 전달되는 ID의 쓰레드가 종료될 때까지 함수는 반환하지 않는다.
status:쓰레드의 main함수가 반환하는 값이 저장될 포인터 변수의 주소 값을 전달한다.
첫 번째 인자로 전달되는 ID의 쓰레드가 종료될 때까지, 이 함수를 호출한 프로세스(또는 쓰레드)를 대기상태에 둔다.
쓰레드의 main함수가 반환하는 값까지 얻을 수 있으니 유용하다.
thread2.c
실행이 일시적으로 정지되었다가 쓰레드가 종료되면서(쓰레드의 main 함수가 반환하면서) 다시 실행이 이어진다.
Process
   ├────────────────→ thread
   │pthread_create()    │
   │                    │
   └────────────────→   │
    pthread_join()      │
   ┌  ←─────────────────┘쓰레드 종료
   │             return
프로세스 종료     

임계영역 내에서 호출이 가능한 함수
쓰레드를 하나 생성하건, 둘을 생성하건 방법에 있어서 차이를 보이진 않는다.
그러나 쓰레드의 실향과 관련해서 주의해야 할 사실이 있다.
둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 함수가 있다.
이는 함수 내에 Critical Sectoin이라 불리고, 둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 문장이 하나 이상 존재하는 함수이다.
임계영역의 문제와 관련해서 함수는 Thread-safe function 이거나 Thread-unsafe function이다.
쓰레드에 안전한 함수는 둘 이상의 쓰레드에 의해서 동시에 호출 및 실행되어도 문제를 일으키지 않는 함수이다.
쓰레드에 불안전한 함수는 동시호출 시 문제가 발생할 수 있는 함수이다.
이것이 임계영역의 유무를 뜻하는 것은 아니다.
쓰레드에 안전한 함수도 임계영역이 존재할 수 있다.
다만 이 영역을 둘 이상의 쓰레드가 동시에 접근해도 문제를 일으키지 않도록 적절한 조치가 이뤄져 있어서 쓰레드에 안전한 함수로 구분.
기본적으로 제공되는 대부분의 표준함수들은 쓰레드에 안전하다.
그리고 쓰레드에 안전한 함수와 불안전한 함수의 구분을 우리가 직접 할 필요가 없다.
왜냐하면 쓰레드에 불안전한 함수가 정의되어 있는 경우, 같은 기능을 갖는 쓰레드에 안전한 함수가 정의되어 있기 때문이다.
struct hostent* gethostbyname(const char *hostname); 은 쓰레드에 안전하지 않다.
동일한 기능을 제공하면서 쓰레드에 안전한 함수가 정의되어 있다.
struct hostent *gethostbyname_r(const char *name, struct hostent *result, char *buffer, int buflen, int *h_errnop);
일반적으로 쓰레드에 안전한 형태로 재구현된 함수의 이름에는 _r이 붙는다.(윈도우는 다르다)
둘 이상의 쓰레드가 동시에 접근 가능한 코드블록에서는 _r을 호출해야해서 귀찮을 수 있다.
다음을 통해 자동화할 수 있다.
헤더파일 선언 이전에 매크로 _REENTRANT를 정의한다.
매크로 정의를 위해서 소스코드에 #define 문장을 추가할 필요도 없다.
컴파일 시 -D_REENTRANㅅ의 옵션을 추가하는 방식으로 매크로를 정의할 수 있기 때문.
# gcc -D_REENTRANT mythread.c -o mythead -lpthread

Worker 쓰레드 모델
쓰레드에게 각각의 역할을 주고 합치는 worker thread 모델.
쓰레드가 main함수가 관리하는 Worker의 형태를 띤다.
                        Process
                           ├─────────────────→ thread
thread  ←──────────────────┤ pthread_create()    │
  │       pthread_create() └─────────────────→   │
  │                          pthread_join()      │
  │                        ┌  ←──────────────────┘쓰레드 종료
  │     ←──────────────────┘            return 1~5
  │          pthread_join()
  └─────────────────────→  ┐
  return 6~10              │1~10
쓰레드 종료            프로세스 종료
thread3.c
두 쓰레드가 하나의 전역변수 sum에 직접 접근한다.
전역변수가 저장되는 데이터 영역을 두 쓰레드가 함께 공유하기 때문에 가능하다.
thread4.c
실행결과는 0이 아니고, 매번 결과도 달라진다.

18-3 쓰레드의 문제점과 Critical Section
하나의 변수에 둘 이상의 쓰레드가 동시에 접근하는 것이 문제
전역변수 num에 둘 이상의 쓰레드가 동시에 접근하고 있다.
어떠한 메모리 공간이라도 동시에 접근을 하면 문제가 발생할 수 있다.
물론 쓰레드들은 CPU의 할당시간을 나눠서 실행하게 된다.
        num:99
thread1       thread2
값의 증가는 CPU를 통한 연산이 필요한 작업이다.
        num:99 -> 100
    99↙↗100
thread1       thread2
그냥 변수 num에 저장된 값이, 변수 num에 저장된 상태로 증가하지는 않는다.
이 변수에 저장된 값은 thread1에 의해서 원 참조가 된다.
thread1은 이 값을 CPU에 전달해서 1이 증가된 값 100을 얻는다.
마지막으로 연산이 완료된 값을 변수 num에 다시 저장한다.
이렇게 해서 변수 num에 100이 저장되는 것이다.
        num:100 -> 101
         101↖↘100
thread1       thread2
이렇게 해서 변수 num에는 101이 저장된다.
이는 매우 이상적인 상황이다.
thread1이 변수 num에 저장된 값을 완전히 증가시키기 전에라도 얼마든지 thread2로 CPU의 실행이 넘어갈 수 있기 때문.
        num:99
    99↙
thread1       thread2
thread1이 변수 num에 저장된 값을 참조해서 1 증가시키는 것까지 완료한 상황.
변수 num에는 아직 증가된 값을 저장하지 않았다.
이제 100이라는 값을 변수 num에 저장ㅇ해야 하는데, 진행되기 전에 thread2로 실행의 순서가 넘어가 버렸다.
thread2는 증가연산을 완전히 완료해서, 증가된 값을 변수 num에 저장했다고 가정.
        num:99 -> 100
         100↖↘99
thread1       thread2
num에 저장된 값이 thread1에 의해서 100으로 증가된 상태가 아니기 때문에 thread2가 참조한 변수 num의 값은 99이다.
thread2에 의해서 변수 num의 값은 100이 되었다.
thread1이 증가시킨 값을 변수 num에 저장하는 일만 남았다.
        num:100 -> 100
       ↗100
thread1       thread2
이미 100으로 증가된 변수 num에 다시 100을 저장하는 일이 발생했다.
이러한 문제를 막기 위해서 한 쓰레드가 변수 num에 접근해서 연산을 완료할 때까지, 다른 쓰레드 변수 num에 접근하지 못하도록 막아야 한다.
이것이 Synchronization.

임계영역은 어디?
함수 내에 둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 하나 이상의 문장으로 묶여있는 코드블록.
num은 문제를 일으키지도 않고, 동시에 실행되지도 않고, 메모리의 할당을 요구하는 변수의 선언일 뿐이다.
일반적으로 임계영역은 쓰레드에 의해서 실행되는 함수 내에 존재한다.
num += 1; num -= 1;
변수 num에 접근하는 두 문장이 임계영역에 해당한다.
이 두 문장은 둘 이상의 쓰레드에 의해서 동시에 실행되도록 구현되어 있는, 문제를 일으키는 직접적인 원인이 되기 때문이다.
1. 두 쓰레드가 동시에 thread_inc 함수를 실행하는 경우
2. 두 쓰레드가 동시에 thread_des 함수를 실행하는 경우
3. 두 쓰레드가 각각 thread_inc함수와 thread_des 함수를 동시에 실행하는 경우
이렇듯 임계영역은 서로 다른 두 문장이 각각 다른 쓰레드에 의해서 동시에 실행되는 상황에서도 만들어질 수 있다.
동일한 메모리 공간에 접근을 한다면 말이다.

18-4 쓰레드 동기화
이 해결책을 가리켜 쓰레드 Synchronization라 한다.

동기화의 두 가지 측면
쓰레드의 동기화는 쓰레드의 접근순서 때문에 발생하는 문제점의 해결책을 뜻한다.
동기화가 필요한 상황
1. 동일한 메모리 영역으로의 동시접근이 발생하는 상황
2. 동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야 하는 상황

