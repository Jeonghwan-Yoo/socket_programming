13-1 send & recv 입출력 함수
리눅스에서의 send & recv
윈도우와 차이가 나지 않는다.
#include <sys/socket.h>
ssize_t send(int sockfd, const void* vuf size_t nbytes, int flags); // 성공 시 전송된 바이트 수, 실패 시 -1반환
sockfd:데이터 전송 대상과의 연결을 의미하는 소켓의 파일 디스크립터 전달.
buf:전송할 데이터를 저장하고 있는 버퍼의 주소 값 전달.
nbytes:전송할 바이트 수 전달.
flags:데이터 전송 시 적용할 다양한 옵션 정보 전달.
#include <sys/socket.h>
ssize_t recv(int sockfd, void* buf, size_t nbytes, int flags); // 성공 시 수신된 바이트 수(단 EOF 전송 시 0), 실패 시 -1 반환
sockfd:데이터 수신 대상과의 연결을 의미하는 소켓의 파일 디스크립터 전달.
buf:수신된 데이터를 저장할 버퍼의 주소 값 전달.
nbytes:수신할 수 있는 최대 바이트 수 전달.
flags:데이터 수신 시 적용할 다양한 옵션 정보 전달.
옵션정보는 비트 OR 연산자를 이용해서 둘 이상을 함께 전달할 수 있다.
Option           의미                                                                                                      send  recv
MSG_OOB          긴급 데이터(Out of band data)의 전송을 위한 옵션                                                             O     O
MSG_PEEK         입력버퍼에 수신된 데이터의 존재유무 확인을 위한 옵션.                                                                O
MSG_DONTROUTE    전송과정에서 Routing테이블을 잠조하지 않을 것을 요구하는 옵션. Local 네트워크 상태에서 목적지를 찾을 때 사용.     O
MSG_DONTWAIT     입출력 함수 호출과정에서 블로킹되지 않을 것을 요구. Non-blocking IO의 요구에 사용되는 옵션.                     O      O
MSG_WAITALL      요청한 바이트 수에 해당하는 데이터가 전부 수신될 때까지, 호출된 함수가 반환되는 것을 막기 위한 옵션.                    O
운영체제마다 조금씩 차이가 날 수 있다.

MSG_OOB:긴급 메시지의 전송
응급환자의 수가 적지 않을 때에는 대기 중에 있는 사람들의 양해가 필요하다.
긴급으로 무엇인가를 처리하려면, 처리방법 및 경로가 달라야 한다.
MSG_OOB는 긴급으로 전송해야 할 메시지가 있어서 메시지의 전송방법 및 경로를 달리하고자 할 때 사용.
oob_send.c
전송은 send함수호출 시 옵션정보로 MSG_OOB를 전달하면되서 간단하다.
oob_recv.c
fcntl(recv_sock, F_SETOWN, getpid()); // 파일 디스크립터 recv_sock이 가리키는 소켓의 소유자를 getpid 함수가 반환하는 ID의 프로세스로 변경시키겠다.
fcntl 함수는 파일 디스크립터의 컨트롤에 사용이 된다.
소켓은 운영체제가 생성 및 관리를 하기 때문에 소켓의 소유자는 운영체제이다.
여기서의 소유자는 이 소켓에서 발생하는 모든 일의 책임 주체를 의미한다.
다시 말하면 소켓에 의해 발생하는 SIGURG 시그널을 처리하는 프로세스.
SIGURG 시그널 처리는 SIGURG 시그널의 핸들러 함수호출을 의미한다.
하나의 소켓에 대한 파일 디스크립터를 여러 프로세스가 함께 소유할 수 있으므로 SIGURG 시그널을 핸들링할 때에는 반드시 시그널을 처리할 프로세스를 지정해 줘야 한다.
그리고 getpid는 이 함수를 호출한 프로세스의 ID를 반환하는 함수이다.
즉 현재 실행중인 프로세스를 SIGURG 시그널의 처리 주체로 지정하는 것.
이 프로그램에서는 프로세스를 하나만 생성하기 때문에 이렇게 해야 한다.
하지만 MSG_OOB 옵션을 추가한다고 해서 더 빨리 데이터가 전송되는 것도 아니고, 시그널 핸들러를 통해서 읽히는 데이터도 1바이트 밖에 되지 않는다.
나머지는 MSG_OOB 옵션이 추가되지 않은 일반적인 입력함수의 호출을 통해서 읽히고 만다.
왜냐하면 TCP는 진정한 의미의 Out-of-band data가 존재하지 않기 때문이다.
Out-of-band data는 전혀 다른 통신 경로로 전송되는 데이터를 의미한다.
그러려면 별도의 통신 경로가 확보되어서 고속으로 데이터가 전송되어야 한다.
하지만 TCP는 별도의 통신 경로를 제공하지 않고 있다.
다만 TCP에 존재하는 Urgent mode라는 것을 이용해서 데이터를 전송해줄 뿐이다.

Urgent mode의 동작 원리
데이터를 수신하는 대상에게 데이터의 처리를 독촉하는데 MSG_OOB의 진정한 의미가 있다.
이것이 전부이고 데이터의 전송에는 전송순서가 그대로 유지된다라는 TCP의 전송특성은 그대롤 유지.
메시지 전송자가 데이터의 처리를 재촉하는 상황에서 보내지기 때문에 긴급 메시지가 맞다.
TCP의 긴급 메시지는 병원으로의 빠른 이동은 보장하지 않는다.
대신에 빠른 응급조치를 요구한다.
빠른 응급조치는 프로그램을 구현하는 개발자들의 몫이다.
긴급 메시지가 전송되었음이 이벤트 핸들러를 통해 인지가 되었었꼬 MSG_OOB 모드 데이터 전송의 실제 의미이다.
offset=0       offset=3(Urgent Pointer)
↓              ↓
8    9    0    .
Urgent Pointer는 긴급 메시지의 다음 번(오프셋이 1 증가한) 위치를 가리키면서 다음의 정보를 상대 호스트에게 전달하는 의미를 갖는다.
Urgent Pointer가 가리키는 오프셋 3의 바로 앞에 존재하는 것이 긴급 메시지야.
긴급 메시지 정보를 실제로 하나의 바이트에만 표시가 된다.
TCP Header = URG=1(긴급 메시지가 존재), URG Pointer=3(위치는 오프셋 3의 위치)
Data = 890
MSG_OOB 옵션이 지정되면 패킷 자체가 긴급 패킷이 되며, Urgent Pointer를 통해서 긴급 메시지의 위치도 표시가 된다.
이 데이터를 수신하는 상대방은 Urgent Pointer의 앞 부분에 위치한 1바이트를 제외한 나머지는 일반적인 입력함수의 호출을 통해서 읽힌다.
긴급 메시지는 메시지 처리를 재촉하는데 의미가 있는 것이지 제한된 형태의 메시지를 긴급으로 전송하는데 의미가 있는 것은 아니다.

컴퓨터 공학에서 말하는 offset
기본이 되는 위치를 바탕으로 상대적 위치를 표현하는 것이 오프셋이다.
기준점으로부터 어느 쪽으로 얼마나 떨어져 있는지를 나타내는 도구가 된다.
때문에 일반적인 주소와 달리 항상 0에서부터 시작하는 것.

입력버퍼 검사하기
MSG_PEEK옵션은 MSG_DONTWAIT 옵션과 함께 설정되어 입력버퍼에 수신된 데이터가 존재하는 지 확인하는 용도로 사용된다.
MSG_PEEK 옵션을 주고 recv 함수를 호출하면 입력버퍼에 존재하는 데이터가 읽혀지ㅓ라도 입력버퍼에서 데이터가 지워지지 않는다.
때문에 MSG_DONTTWAIT옵션과 묶여서 블로킹 되지 않는, 데이터의 존재유무를 확인하기 위한 함수의 호출 구성에 사용된다.
peek_send.c
peek_recv.c
한번밖에 전송되지 않은 데이터가 두 번 읽혀진다.
첫 번째 recv 함수호출 시 MSG_PEEK 옵션을 지정했기 때문.

13-2 readv & writev 입출력 함수
데이터 송수신의 효율성을 향상시키는데 도움이 되는 함수들.

readv & writev 함수의 사용
데이터를 모아서 전송하고, 모아서 수신하는 기능의 함수
writev 함수를 사용하면 여러 버퍼에 나뉘어 저장되어 있는 데이터를 한번에 전송할 수 있고, readv 함수를 사용하면 데이터를 여러 버퍼에 나눠서 수신할 수 있다.
적절한 상황에서 사용을 하면 입출력 함수호출의 수를 줄일 수 있다.
#include <sys/uio.h>
ssize_t writev(int filedes, const struct iovec* iov, int iovcnt); // 성공 시 전송된 바이트 수, 실패 시 -1 반환
filedes:데이터 전송의 목적지를 나타내는 소켓의 파일 디스크립터 전달. 파일이나 콘솔 대상의 파일 디스크립터도 전달가능.
iov:구조체 iovec 배열의 주소 값 전달. 구조체 iovec의 변수에는 전송할 데이터의 위치 및 크기 정보가 담긴다.
iovcnt:두 번째 인자로 전달된 주소 값이 가리키는 배열의 길이정보 전달.
struct iovec {
    void* iov_base; // 버퍼의 주소 정보
    size_t iov_len; // 버퍼의 크기 정보
};
iovec은 전송할 데이터가 저장되어 있는 버퍼(char형 배열)의 주소 값과 실제 전송할 데이터의 크기 정보를 담기 위해 정의.
writev(1, ptr, 2);    buffer
ptr -> iov_base    -> ABC
       iov_len = 3
       iov_base    -> 1234
       iov_len = 4
1은 파일 디스크립터를 의미하므로 콘솔에 출력이 이뤄지고, ptr은 전송할 데이터 정보를 모아둔 iovec 배열을 가리키는 포인터이다.
세 번째 인자가 2이기 때문에 ptr이 가리키는 주소를 시작으로 총 두 개의 iovec 변수를 참조하여, 그 두 변수가 가리키는 버퍼에 저장된 데이터의 전송이 진행된다.
ptr[0]의 iov_base는 A로 시작하는 문자열을 가리키면서, iov_len이 3이므로 ABC가 전송.
ptr[1]의 iov_base는 1을 가리키며 iov_len이 4이므로 1234가 이어서 전송된다.
writev.c
readv함수는 writev 함수와 반대.
#include <sys/uio.h>
ssize_t readv(int filedes, const struct iovec* iov, int iovcnt); // 성공 시 수신된 바이트 수, 실패 시 -1 반환
filedes:데이터를 수신한 파일(혹은 소켓)의 파일 디스크립터를 인자로 전달.
iov:데이터를 저장할 위치와 크기 정보를 담고 있는 iovec 구조체 배열의 주소 값 전달.
iovcnt:두 번째 인자로 전달된 주소 값이 가리키는 배열의 길이정보 전달.
readv.c

readv & writev 함수의 적절한 사용
사용할 수 있는 모든 경우가 적절한 상황이다.
전송해야 할 데이터가 여러 개의 버퍼에 나뉘어 있는 경우, 모든 데이터의 전송을 위해서는 여러 번의 write 함수호출이 요구되는데,
이를 딱 한번의 writev 함수호출로 대신할 수 있으니 효율적이다.
입력버퍼에 수신된 데이터를 여러 저장소에 나눠서 읽어 들이고 싶은 경우에도 여러 번 read 함수를 호출하는 것보다 딱 한번 readv 함수를 호출하는 것이 효율적.
하지만 전송되는 패킷의 수를 줄일 수 있다는데 더 큰 의미가 있다.
writev 함수는 Nagle 알고리즘이 중지된 상황에서 더 활용의 가치가 높다.
write 함수를 사용할 경우 총 세 번의 함수호출이 필요하다고 하자.
그런데 속도향상을 목적으로 이미 Nagle 알고리즘이 중지된 상황이라면, 총 세 개의 패킷이 생성되어 전송될 확률이 높다.
wrtiev 함수를 사용할 경우, 한번에 모든 데이터를 출력버퍼로 밀어 넣기 때문에 하나의 패킷만 생성되어서 전송될 확률이 높다.
여러 영역에 나뉘어 있는 데이터를 전송순서에 맞춰 하나의 큰 배열에 놓고 한번에 write를 해도되지만 함수가 더 편하다.

13-3 윈도우 기반으로 구현하기
윈도우에는 리눅스에서 보인 형태의 시그널 핸들링이 존재하지 않습니다.
그래서 select 함수를 통해서 해결.
1. 수신한 데이터를 지니고 있는 소켓이 존재하는가?
2. 블로킹되지 않고 데이터의 전송이 가능한 소켓은 무엇인가?
3. 예외상황이 발생한 소켓은 무엇인가?
예외상황이라는 것은 일반적이지 않은 프로그램의 흐름을 의미하기 때문에 Out-of-band 데이터이ㅡ 수신도 예외상황에 해당이 된다.
select 함수의 이러한 특성을 활용하면 Out-of-band 데이터의 수신을 확인할 수 있다.