13-1 send & recv 입출력 함수
리눅스에서의 send & recv
윈도우와 차이가 나지 않는다.
#include <sys/socket.h>
ssize_t send(int sockfd, const void* vuf size_t nbytes, int flags); // 성공 시 전송된 바이트 수, 실패 시 -1반환
sockfd:데이터 전송 대상과의 연결을 의미하는 소켓의 파일 디스크립터 전달.
buf:전송할 데이터를 저장하고 있는 버퍼의 주소 값 전달.
nbytes:전송할 바이트 수 전달.
flags:데이터 전송 시 적용할 다양한 옵션 정보 전달.
#include <sys/socket.h>
ssize_t recv(int sockfd, void* buf, size_t nbytes, int flags); // 성공 시 수신된 바이트 수(단 EOF 전송 시 0), 실패 시 -1 반환
sockfd:데이터 수신 대상과의 연결을 의미하는 소켓의 파일 디스크립터 전달.
buf:수신된 데이터를 저장할 버퍼의 주소 값 전달.
nbytes:수신할 수 있는 최대 바이트 수 전달.
flags:데이터 수신 시 적용할 다양한 옵션 정보 전달.
옵션정보는 비트 OR 연산자를 이용해서 둘 이상을 함께 전달할 수 있다.
Option           의미                                                                                                      send  recv
MSG_OOB          긴급 데이터(Out of band data)의 전송을 위한 옵션                                                             O     O
MSG_PEEK         입력버퍼에 수신된 데이터의 존재유무 확인을 위한 옵션.                                                                O
MSG_DONTROUTE    전송과정에서 Routing테이블을 잠조하지 않을 것을 요구하는 옵션. Local 네트워크 상태에서 목적지를 찾을 때 사용.     O
MSG_DONTWAIT     입출력 함수 호출과정에서 블로킹되지 않을 것을 요구. Non-blocking IO의 요구에 사용되는 옵션.                     O      O
MSG_WAITALL      요청한 바이트 수에 해당하는 데이터가 전부 수신될 때까지, 호출된 함수가 반환되는 것을 막기 위한 옵션.                    O
운영체제마다 조금씩 차이가 날 수 있다.

MSG_OOB:긴급 메시지의 전송
응급환자의 수가 적지 않을 때에는 대기 중에 있는 사람들의 양해가 필요하다.
긴급으로 무엇인가를 처리하려면, 처리방법 및 경로가 달라야 한다.
MSG_OOB는 긴급으로 전송해야 할 메시지가 있어서 메시지의 전송방법 및 경로를 달리하고자 할 때 사용.
oob_send.c
전송은 send함수호출 시 옵션정보로 MSG_OOB를 전달하면되서 간단하다.
oob_recv.c
fcntl(recv_sock, F_SETOWN, getpid()); // 파일 디스크립터 recv_sock이 가리키는 소켓의 소유자를 getpid 함수가 반환하는 ID의 프로세스로 변경시키겠다.
fcntl 함수는 파일 디스크립터의 컨트롤에 사용이 된다.
소켓은 운영체제가 생성 및 관리를 하기 때문에 소켓의 소유자는 운영체제이다.
여기서의 소유자는 이 소켓에서 발생하는 모든 일의 책임 주체를 의미한다.
다시 말하면 소켓에 의해 발생하는 SIGURG 시그널을 처리하는 프로세스.
SIGURG 시그널 처리는 SIGURG 시그널의 핸들러 함수호출을 의미한다.
하나의 소켓에 대한 파일 디스크립터를 여러 프로세스가 함께 소유할 수 있으므로 SIGURG 시그널을 핸들링할 때에는 반드시 시그널을 처리할 프로세스를 지정해 줘야 한다.
그리고 getpid는 이 함수를 호출한 프로세스의 ID를 반환하는 함수이다.
즉 현재 실행중인 프로세스를 SIGURG 시그널의 처리 주체로 지정하는 것.
이 프로그램에서는 프로세스를 하나만 생성하기 때문에 이렇게 해야 한다.
하지만 MSG_OOB 옵션을 추가한다고 해서 더 빨리 데이터가 전송되는 것도 아니고, 시그널 핸들러를 통해서 읽히는 데이터도 1바이트 밖에 되지 않는다.
나머지는 MSG_OOB 옵션이 추가되지 않은 일반적인 입력함수의 호출을 통해서 읽히고 만다.
왜냐하면 TCP는 진정한 의미의 Out-of-band data가 존재하지 않기 때문이다.
Out-of-band data는 전혀 다른 통신 경로로 전송되는 데이터를 의미한다.
그러려면 별도의 통신 경로가 확보되어서 고속으로 데이터가 전송되어야 한다.
하지만 TCP는 별도의 통신 경로를 제공하지 않고 있다.
다만 TCP에 존재하는 Urgent mode라는 것을 이용해서 데이터를 전송해줄 뿐이다.

Urgent mode의 동작 원리
데이터를 수신하는 대상에게 데이터의 처리를 독촉하는데 MSG_OOB의 진정한 의미가 있다.
이것이 전부이고 데이터의 전송에는 전송순서가 그대로 유지된다라는 TCP의 전송특성은 그대롤 유지.
메시지 전송자가 데이터의 처리를 재촉하는 상황에서 보내지기 때문에 긴급 메시지가 맞다.
TCP의 긴급 메시지는 병원으로의 빠른 이동은 보장하지 않는다.
대신에 빠른 응급조치를 요구한다.
빠른 응급조치는 프로그램을 구현하는 개발자들의 몫이다.
긴급 메시지가 전송되었음이 이벤트 핸들러를 통해 인지가 되었었꼬 MSG_OOB 모드 데이터 전송의 실제 의미이다.
offset=0       offset=3(Urgent Pointer)
↓              ↓
8    9    0    .
Urgent Pointer는 긴급 메시지의 다음 번(오프셋이 1 증가한) 위치를 가리키면서 다음의 정보를 상대 호스트에게 전달하는 의미를 갖는다.
Urgent Pointer가 가리키는 오프셋 3의 바로 앞에 존재하는 것이 긴급 메시지야.
긴급 메시지 정보를 실제로 하나의 바이트에만 표시가 된다.
TCP Header = URG=1(긴급 메시지가 존재), URG Pointer=3(위치는 오프셋 3의 위치)
Data = 890
MSG_OOB 옵션이 지정되면 패킷 자체가 긴급 패킷이 되며, Urgent Pointer를 통해서 긴급 메시지의 위치도 표시가 된다.
이 데이터를 수신하는 상대방은 Urgent Pointer의 앞 부분에 위치한 1바이트를 제외한 나머지는 일반적인 입력함수의 호출을 통해서 읽힌다.
긴급 메시지는 메시지 처리를 재촉하는데 의미가 있는 것이지 제한된 형태의 메시지를 긴급으로 전송하는데 의미가 있는 것은 아니다.

컴퓨터 공학에서 말하는 offset
기본이 되는 위치를 바탕으로 상대적 위치를 표현하는 것이 오프셋이다.
기준점으로부터 어느 쪽으로 얼마나 떨어져 있는지를 나타내는 도구가 된다.
때문에 일반적인 주소와 달리 항상 0에서부터 시작하는 것.

입력버퍼 검사하기
MSG_PEEK옵션은 MSG_DONTWAIT 옵션과 함께 설정되어 입력버퍼에 수신된 데이터가 존재하는 지 확인하는 용도로 사용된다.
MSG_PEEK 옵션을 주고 recv 함수를 호출하면 입력버퍼에 존재하는 데이터가 읽혀지ㅓ라도 입력버퍼에서 데이터가 지워지지 않는다.
