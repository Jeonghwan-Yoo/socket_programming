12-1 IO 멀티플렉싱 기반의 서버
멀티프로세스 서버의 단점과 대안
클라이언트의 연결요청이 있을 때마다 새로운 프로세스를 생성하였지만 많은 양의 연산이 요구되며 필요한 메모리 공간도 큰 편.
프로세스마다 별도의 메모리 공간을 유지하기 때문에 상호간에 데이터를 주고받으려면 다소 복잡한 방법을 택할 수 밖에 없다.(IPC는 다소 복잡한 통신방법)
프로세스의 생성을 동반하지 않으면서 다수의 클라이언트에게 서비스를 제공하는 방법으로 IO 멀티플렉싱 서버가 있다.
하지만 구현하고자 하는 서버의 특성에 따라서 구현방법은 달리 결정되어야 한다.
즉, 이 방법이 모든 경우에 있어서 최선은 아니다.

멀티플렉싱이라는 단어의 이해
하나의 통신채널을 통해서 둘 이상의 데이터(시그널)를 전송하는데 사용되는 기술.
물리적 장치의 효율성을 높이기 위해서 최소한의 물리적인 요소만 사용해서 최대한의 데이터를 전달하기 위해 사용되는 기술.
컵으로 3명이 통신하려면 컵 2개씩 들고 있어야하는 것을 3개를 이으면 한 개만 있어도 된다.
대화를 하는 것이기 때문에 동시에 말을 하는 상황이 자주 등장하지는 않는다. time 분할 멀티플렉싱 기술이 적용되었다.
목소리 톤이 다르기 때뭉네 목소리를 어느정도 구분할 수 있다. frequency 분할 멀티플렉싱 기술도 적용되었다.

멀티플렉싱의 개념을 서버에 적용하기
서버에 멀티플렉싱 기술을 도입해서 필요한 프로세스의 수를 줄일 수 있다.
멀티 프로세스 서버 모델
Server
Child <-> Client
Child <-> Client
Child <-> Client
프로세스의 수가 줄어든다.
접속해있는 클라이언트의 수에 상관없이, 서비스를 제공하는 프로세스의 수는 딱하나이다.
멀티플렉싱 서버 모델
Server <-> Client
       <-> Client
       <-> Client

IO멀티플렉싱 서버 모델의 또 다른 이해
IO 멀티플렉싱 서버에서는 프로세스가 데이터가 수신된 소켓이 있는지 확인을 한다.
그래서 그 소켓을 통해서 전송된 데이터를 수신하게 된다.

12-2 select 함수의 이해와 서버의 구현
select 함수를 이용하는 것이 멀티플렉싱 서버의 구현에 가장 대표적인 방법.
윈도우에도 동일한 이름으로 동일한 기능을 제공하는 함수가 있기 때문에 이식성에 있어서도 좋다.

select 함수의 기능과 호출순서
select 함수를 사용하면 한곳에 여러 개의 파일 디스크립터를 모아놓고 동시에 이들을 관찰할 수 있다.
1. 수신한 데이터를 지니고 있는 소켓이 존재하는가?
2. 블로킹되지 않고 데이터의 전송이 가능한 소켓은 무엇인가?
3. 예외상황이 발생한 소켓은 무엇인가?
관찰항목 각각을 이벤트라 하고, 관찰항목에 속하는 상황이 발생했을 때, event가 발생했다고 한다.
멀티플렉싱 서버의 구현을 위해서는 select 함수를 잘 이해하고 이를 소켓에 적용해야 한다.

select 함수의 호출 과정
1. 파일 디스크립터의 설정, 검사의 범위 지정, 타임아웃의 설정
2. select 함수의 호출
3. 호출결과 확인

파일 디스크립터의 설정
select 함수를 사용하면 여러 개의 파일 디스크립터(소켓)를 동시에 관찰할 수 있다.
관찰하고자 하는 파일 디스크립터를 모아야 한다.
모을 때도 수신, 전송, 예외에 따라서 구분해서 모아야 한다.
파일 디스크립터를 세 묶음으로 모을 때 사용되는 것이 fd_set형 변수이다.
이는 0과 1로 표현되는 비트단위로 이뤄진 배열이다.
fd_set
fd0 fd1 fd2 fd3
 0   1   0   1 ...
비트는 1로 설정되면 해당 파일 디스크립터가 관찰의 대상임을 의미.
위에선 파일 디스크립터 1과 3이 관찰대상으로 지정.
fd_set형 변수의 조작은 비트단위로 이뤄지기 때문에 fd_set형 변수에 값을 등록하거나 변경하는 등의 작업은 매크로 함수들의 도움을 통해서 이뤄진다.
FD_ZERO(fd_set* fdset) // 인자로 전달된 주소의 fd_set형 변수의 모든 비트를 0으로 초기화한다.
FD_SET(int fd, fd_set* fdset) // 매개변수 fdset으로 전달된 주소의 변수에 매개변수 fd로 전달된 파일 디스크립터 정보를 등록한다.
FD_CLR(int fd, fd_set* fdset) // 매개변수 fdset으로 전달된 주소의 변수에서 매개변수 fd로 전달된 파일 디스크립터 정보를 삭제한다.
FD_ISSET(int fd, fd_set* fdset) // 매개변수 fdset으로 전달된 주소의 변수에 매개변수 fd로 전달된 파일 디스크립터 정보가 있으면 양수를 반환한다.
FD_ISSET은 setlect 함수의 호출결과를 확인하는 용도로 사용한다.
int main(void) {
    fd_set set;
    FD_ZERO(&set); // 0 0 0 0
    FD_SET(1, &set); // 0 1 0 0
    FD_SET(2, &set); // 0 1 1 0
    FD_CLR(2, &set); // 0 1 0 0
}

검사(관찰)의 범위지정과 타임아웃의 설정
#include <sys/select.h>
#include <sys/time.h>
int select(int maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timeval* timeout); // 성공 시 0 이상, 실패 시 -1 반환
maxfd:검사 대상이 되는 파일 디스크립터의 수.
readset:fd_set형 변수에 수신된 데이터의 존재여부에 관심있는 파일 디스크립터 정보를 모두 등록해서 그 변수의 주소 값을 전달한다.
writeset:fd_set형 변수에 블로킹 없는 데이터 전송의 가능여부에 관심 있는 파일 디스크립터 정보를 모두 등록해서 그 변수의 주소 값을 전달한다.
exceptset:fd_set형 변수에 예외상황의 발생여부에 관심이 있는 파일 디스크립터 정보를 모두 등록해서 그 변수의 주소 값을 전달한다.
timeout:select함수호출 이후에 무한정 블로킹 상태에 빠지지 않도록 time-out을 설정하기 위한 인자를 전달한다.
반환 값:오류발생시에는 -1이 반환되고, 타임 아웃에 의한 반환 시에는 0이 반환된다. 
관심대상으로 등록된 파일 디스크립터에 해당 관심에 관련된 변화가 발새앟면 0보다 큰 값을 반환되는데, 변화가 발생한 파일 디스크립터의 수를 의미한다.
세가지 관찰항목별로 fd_set형 변수를 선언해서 파일 디스크립터 정보를 등록하고, 이 변수의 주소 값을 2, 3, 4번째 인자로 전달하게 된다.

이에 앞서 다음 두 가지를 먼저 결정해야 한다.
1. 파일 디스크립터의 관찰 범위는 어떻게 되지?
2. select 함수의 타임아웃 시간을 어떻게 할까?
파일 디스크립터의 관찰(검사) 범위는 select 함수의 첫 번째 매개변수와 관련이 있다.
select함수는 관찰의 대상이 되는 파일 디스크립터의 수를 첫 번째 인자로 요구하고 있다.
fd_set형 변수에 등록된 파일 디스크립터의 수를 확인할 필요가 있는데, 파일 디스크립터의 값은 생성될 때마다 1씩 증가하기에 가장 큰 파일 디스크립터의 값에 1을 더해 인자로 전달한다.
1을 더하는 이유는 파일 디스크립터의 값이 0에서부터 시작하기 때문이다.
select 함수의 타임아웃 시간은 select 핫무의 마지막 매개변수와 관련이 있다.
struct timeval {
    long tv_sec; // seconds
    long tv_usec; // microseconds
}
원래 select 함수는 관찰중인 파일 디스크립터에 변화가 생겨야 반환을 한다.
변화가 생기지 않으면 무한정 블로킹 상태에 머물게 된다.
이러한 상황을 막기 위해서 타임아웃을 지정하는 것.
tv_sec에 초 단위 정보를, tv_usec에 마이크로 초 단위 정보를 지정하고, 변수의 주소 값을 select 함수의 마지막 인자로 전달을 하면,
파일 디스크립터에 변화가 발생하지 않아도 지정된 시간이 지나면 함수가 반환을 한다.
이렇게 해서 반환이 되는 경우, select 함수는 0을 반환한다. 반환 값을 통해서 반환의 원인을 알 수 있다.
타임아웃을 설정하고 싶지 않을 경우에는 NULL을 인자로 전달하면 된다.

select 함수호출 이후의 결과확인
중요한 것이 함수호출의 결과를 확인하는 방법이다.
0이 아닌 양수가 반환이 되면, 그 수만큼 파일 디스크립터에 변화가 발생했다.

파일 디스크립터의 변화
관심대상으로 등록된 파일 디스크립터에 해당관심에 관련된 변화가 발생했음을 뜻한다.
seelct 함수의 두 번째 인자를 통해서 데이터 수신여부의 관찰 대상에 포함된 파일 디스크립터로 수신된 데이터가 존재하는 경우가 파일 디스크립터에 변화가 발생한 경우.
select 함수의 2, 3, 4에 전달된 fd_set형 변수에 보이는 변화가 발생하기 때문에 어렵지 않게 알아낼 수 있다.
select 함수호출이 완료되고 나면, select 함수의 인자로 전달된 fd_set형 변수에는 변화가 생긴다.
1로 설정된 모든 비트가 다 0으로 변경되지만, 변화가 발생한 파일 디스크립터에 해당하는 비트만 그대로 1로 남아있게 된다.
여전히 1로 남아있는 위치의 파일 디스크립터에서 변화가 발생했다고 판단할 수 있다.

최종! select 함수를 호출하는 예제의 확인
