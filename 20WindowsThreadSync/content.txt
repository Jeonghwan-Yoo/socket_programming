20-1 동기화 기법의 분류와 CRITICAL_SECTION 동기화
User mode와 Kernel mode
윈도우 운영체제의 연산방식(프로그램 실행방식)을 가리켜 Dual-mode  Operation 방식이라 한다.
유저모드:응용 프로그램이 실행되는 기본모드로, 물리적인 영역으로의 접근이 허용되지 않으며, 접근할 수 있는 메모리의 영역에도 제한이 따른다. => 응용 프로그램의 실행 모드
커널모드:운영체제가 실행될 때의 모드로, 메모리뿐만 아니라, 하드웨어의 접근에도 제한이 따르지 않는다. => 운영체제의 실행 모드
커널은 운영체제의 핵심모듈.
하지만 응용 프로그램의 실행과정에서 윈도우 운영체제가 항상 유저모드에만 머무는 것이 아니라, 유저모드와 커널모드를 오가며 실행하게 된다.
쓰레드의 생성요청은 응용 프로그램상에서의 함수호출을 통해서 이뤄지지만, 쓰레드를 실제로 생성하는 것은 운영체제다.
쓰레드의 생성을 위해서는 커널모드로의 전환이 불가피.
두 가지 모드를 정의하고 있는 이유는 안정성.
응용 프로그램상에서의 잘못된 연산은 운영체제의 손상 및 다양한 리소스들의 손상으로 이어질 수 있다.
C/C++은 포인터 연산이 가능하기 때문에 흔히 일어날 수 있다.
잘못된 포인터 연산을 통해서 운영체제의 중요 데이터가 저장되어 있는 메모리 영역을 덮어썼다고 해서 불상사를 경험하진 않았다.
유저모드로 실행되는 과정에서는 운영체제와 관련된 메모리 영역이 보호받기 때문이다.
잘못된 포인터 연산을 하는 경우에는 프로그램이 종료될지언정 운영체제가 망가지지는 않는다.
쓰레드와 같이 커널 오브젝트의 생성을 동반하는 리소스의 생성을 위해서는 다음 모드 변환의 과정을 기본적으로 거쳐야 한다.
유저모드 -> 커널모드 -> 유저모드
유저모드->커널모드:리소스의 생성을 위함.
커널모드->유저모드:응용 프로그램의 나머지 부분을 이어서 실행하기 위한 것.
리소스의 생성뿐만 아니라, 커널 오브젝트와 관련된 모든 일은 커널모드에서 진행이 되는데, 모드의 변환 역시 시스템에 부담이 되는 일이기에 빈번하면 성능에 영향을 줄 수 있다.

유저모드 동기화
유저모드상에서 진행되는 동기화를 말한다.
운영체제의 도움 없이 응용 프로그램상에서 진행되는 동기화.
커널모드로의 전환이 불필요하기 때문에, 빠르다.
사용방법도 간단한 편이니 유저모드 동기화가 적절한 상황에서는 적극 활용하는 것도 좋다.
하지만 운영체제의 힘을 빌리지 않는 동기화 기법이기에 기능은 제한적.
CRITICAL SECTION이 있다.

커널모드 동기화
유저모드 동기화에 비해 제공되는 기능이 더 많다.
Dead-lock에 걸리지 않도록 타임아웃의 지정이 가능하다.
커널모드에서 동기화를 진행하면, 서로 다른 프로세스에 포함되어 있는 두 쓰레드간의 동기화도 가능하다.
반면 모드의 빈번한 변환이 불가피하기 때문에 성능에 있어서의 제약이 따른다.
커널 오브젝트를 기반으로 하기 때문에 서로 다른 프로세스 사이에서의 동기화도 가능하다.
커널 오브젝트는 운영체제에 의해서 소유 및 관리되기 때문이다.

Dead-lock
임계영역으로의 진입을 대기중인, 블로킹 상태에 놓여있는 쓰레드가 이를 빠져 나오지 못하는 상황.
Dead-lock은 매우 다양한 상황에서 발생한다.
pthread_mutex_lock함수를 호출하면서 임계영역에 진입한 쓰레드가 pthread_mutex_unlock함수를 호출하지 않아도 Dead-lock 상황은 발생.
대부분의 경우, 원인의 파악조차 어려울 정도로 애매한 상황에서 발생.

CRITICAL_SECTION 기반의 동기화
CRITICAL_SECTION 오브젝트를 생성해서 이를 통기화에 활용한다.
이는 커널 오브젝트가 아니며, 대부분의 다른 동기화 오브젝트와 같이 임계영역의 진입에 필요한 Key로 이해할 수 있다.
때문에 임계영역의 진입을 위해서는 CRITICAL_SECTION을 얻어야 하고, 나갈때는 반납해야 한다.
#include <windows.h>
void InitializeCriticalSection(LPCRTICAL_SECTION lpCriticialSection);
void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
lpCriticalSection:init에서는 초기화 할 CRITICAL_SECTION 오브젝트의 주소 값 전달. Delete에서는 해제할 CRITICAL_SECTION 주소 값 전달.
LPCRITICAL_SECTION은 CRITICAL_SECTION의 포인터 형.
DeleteCriticalSection 함수는 CRITICAL_SECTION 오브젝트를 소멸하는 함수가 아니라 오브젝트가 사용하던(연관되어 있는)리소스를 소멸시키는 함수이다.
#include <windows.h>
void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
lpCriticalSection:획득 및 반납할 CRITICAL_SECTION 오브젝트의 주소값 전달.
SyncCS_win.c
반복문 전체를 임계영역으로 잡은 이유는 실행시간의 단축을 위한 것.
변수 num에 접근하는 하나의 문장만 임계영역으로 잡으면 오래걸린다.
매우 많은 수의 CS 오브젝트 획득 및 반납이 이뤄지기 때문.

20-2 커널모드 동기화 기법

