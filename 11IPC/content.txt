11-1 프로세스간 통신의 기본 개념
서로 다른 두 프로세스가 데이터를 주고 받을 수 있다는 의미.
두 프로세스가 동시에 접근 가능한 메모리 공간이 필요하다.

프로세스간 통신의 기본 이해
두 프로세스가 동시에 접근 가능한 메모리 공간만 있다면, 얼마든지 데이터를 주고 받을 수 있다.
프로세스는 서로 완전히 별개의 메모리 구조를 지닌다.
프로세스간 통신은 별도로 마련한 방법을 통해서만 이뤄질 수 있다.

Pipe 기반의 프로세스간 통신
Process A ---------- Process B
             PIPE
두 프로세스간 통신을 위해서는 파이프라는 것을 생성해야 한다.
이 파이프는 프로세스에 속하는 자원이 아닌 소켓처럼 운영체제에 속하는 자원이다.
운영체제가 마련해 주는 메모리 공간을 통해서 두 프로세스는 통신을 하게 된다.
#include <unistd.h>
int pipe(int filedes[2]); // 성공 시 0, 실패시 -1 반환
filedes[0]:파이프로부터 데이터를 수신하는데 사용되는 파일 디스크립터가 저장된다. 파이프의 출구가 된다.
filedes[1]:파이프로부터 데이터를 전송하는데 사용되는 파일 디스크립터가 전송된다. 파이프의 입구가 된다.
부모 프로세스가 위의 함수를 호출하면 파이프가 생성되고, 파이프의 입구 및 출구에 해당하는 파일 디스크립터를 동시에 얻게 되는 것이다.
부모 프로세스 혼자서 안으로 데이터를 집어넣고 꺼내는 것도 가능하다.
부모 프로세스의 목적은 자식 프로세스와의 데이터 송수신이니, 입구 또는 출구에 해당하는 파일 디스크립터 중 하나를 자식 프로세스에게 전달해야 한다.
답은 fork함수 호출에 있다.
pipe1.c
부모, 자식 프로세스 모두 파이프의 입출력 경로에 접근이 가능하지만, 자식은 입력 경로에만, 부모는 출력 경로에만 접근해서 통신을 했다.
Child Process fds[1]--->|       PIPE        |    fds[1] Parent Process
              fds[0] in |                   |--->fds[0]
                                             out

PIPE 기반의 프로세스간 양방향 통신
Child Process fds[1]--->|       PIPE        |<---fds[1] Parent Process
              fds[0]<---|                   |--->fds[0]
하나의 파이프를 대상으로 양방향으로 통신을 하는 것도 가능하다.
pipe2.c                                            
자식 프로세스의 실행시간을 2초 정도 늦추는 코드이지만 주석처리하면 문제가 발생한다.
파이프에 데이터가 전달되면, 먼저 가져가는 프로세스에게 이 데이터가 전달된다.
파이프에 데이터가 들어가면 임자가 없는 데이터가 된다.
read 함수호출을 통해서 먼저 데이터를 읽어 들이는 프로세스에게 데이터가 전달된다.
프로그램의 실행흐름을 예측하고 컨트롤해야 하는데, 시스템에 따라서 달라져야 하는 부분이기 때문에 사실상 불가능.
이를 위해 두 개의 파이프를 생성해서 각각이 서로 다른 데이터의 흐름을 담당하게 하면 된다.
Child Process fds[1]--->|       PIPE        |--->fds[0] Parent Process
              fds[0]<---|       PIPE        |<---fds[1]
pipe3.c

11-2 프로세스간 통신의 적용
