TCP 소켓의 경우 연결을 지향하기 때문에 스트림 기반 소켓.
Transmission Control Protocol.

TCP/IP 프로토콜 스택
TCP/IP 스택이 총 네 개의 계층으로 나뉜다.
TCP 소켓을 생성해서 데이터를 송수신할 경우에는 네 계층의 도움을 통해서 데이터를 송수신하게 된다.
LINK <-> IP <-> TCP <-> APPLICATION
UDP 소켓을 생성해서 데이터를 송수신할 경우에는 다음 네 계층의 도움을 통해서 데이터를 송수신하게 된다.
LINK <-> IP <-> UDP <-> APPLICATION
각각의 계층을 담당하는 것은 운영체제와 같은 소프트웨어이기도 하고 NIC와 같은 물리적인 장치이기도 하다.

OSI7 Layer
데이터 통신에 사용되는 프로토콜 스택은 7계층으로 세분화된다.

TCP/IP 프로토콜의 탄생배경
소프트웨어가 존재하기 전에 하드웨어적으로 시스템이 구축되어 있어야 하고, 그러한 물리적 환경을 기반으로 각종 소프트웨어적인 알고리즘을 필요로 한다.
상호 논의로 만들어진 다양한 약속이 또한 필요하다.
이 문제는 작은 문제로 나눠서 해결하는 것이 효율적.
문제를 영역별로 나눠서 해결하다 보니 프로토콜이 여러 개 만들어졌으며, 이들은 계층구조를 통해서 상호간에 관계를 맺게 되었다.

Open System
프로토콜을 계층화하면 설계하기 용이하고, 표준화작업을 통한 Open System의 설계이다.
여러 개의 표준을 근거로 설계된 시스템을 개방형 시스템.
모든 라우터 제조사들이 IP 계층의 표주넹 맞춰서 라우터를 제작하기에 교체해도 괜찮다.
모든 랜카드 제조사도 LINK 계층의 표준을 따르고 있다.
이를 통해 빠른 속도의 기술발전이 가능하다.

LINK 계층
물리적인 영역의 표준화에 대한 결과이다.
가장 기본이 되는 영역으로 LAN, WAN, MAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역.

IP 계층
복잡하게 연결되어 있는 인터넷을 통한 데이터의 전송을 위해 선행되어야 할 일은 경로의 선택이다.
이 문제를 해결하는 것이 IP 계층이고 Internet Protocol을 이용한다.
IP 자체는 비연결지향적이며 신뢰할 수 없는 프로토콜이다.
데이터를 전송할 때마다 거쳐야 할 경로를 선택해 주지만, 그 경로는 일정치 않다.
특히 데이터 전송 중에 경로상에 문제가 발생하면 다른 경로를 선택해 주는데, 이 과정에서 데이터가 손실되거나
오류가 발생하는 등의 문제가 발생한다고 해서 이를 해결해주지 않는다.
즉, 오류발생에 대한 대비가 되어있지 않은 프로토콜이다.

TCP/UDP 계층
그 경로를 기준으로 데이터를 전송만하면 된다.
IP계층에서 알려준 경로정보를 바탕으로 데이터의 실제 송수신을 담당한다.
그래서 Transport 계층이라 한다.
UDP는 상대적으로 간단하다.
TCP는 신뢰성 있는 데이터의 전송을 담당한다.
그런데 TCP가 데이터를 보낼 때 기반이 되는 프로토콜이 IP이다.
IP는 오로지 하나의 데이터 패킷이 전송되는 과정에만 중심을 두고 설계되었다.
따라서 여러 개의 데이터 패킷을 전송한다 하더라도 각각의 패킷이 전송되는 과정은 IP에 의해서 진행되므로 전송의 순서와 그 자체를 신뢰할 수 없다.
반면에 TCP 프로토콜이 추가되어 데이터를 송수신하면 대화를 주고 받게 된다.
데이터를 주고받는 과정에서 서로 데이터의 주고 받음을 확인하고 분실된 데이터에 대해서 재전송해준다.
IP의 상위계층에서 호스트 대 호스트의 데이터 송수신 방식을 약속하는 것이 TCP 그리고 UDP이며,
TCP는 확인절차를 걸쳐서 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜이다.

APPLICATION 계층
지금까지는 소켓을 생성하면 데이터 송수신과정에서 자동으로 처리되는 것들이다.
최종적으로 소켓이라는 도구가 주어졌고, 무엇인가를 만들면 되고 그 과정에서 프로그램의 성격에 따라
클라이언트와 서버간의 데이터 송수신에 대한 약속들이 정해지기 마련인데 APPLICATION 프로토콜이다.

04-2 TCP기반 서버, 클라이언트 구현
TCP 서버에서의 기본적인 함수호출 순서
socket() --------> bind() --------> listen() ----------> accept() ----------> read()/write() -----------> close()
소켓 생성          소켓 주소 할당   연결요청 대기상태       연결허용               데이터 송수신              연결 종료
socket 함수의 호출을 통해 소켓을 생성한다.
주소정보를 담기 위한 구조체 변수를 선언 및 초기화해서 bind 함수를 호출하여 소켓에 주소를 할당한다.

연결요청 대기상태로의 진입
소켓에 주소까지 할당했다면, 연결요청 대기상태로 들어갈 차례.
listen 함수가 호출되어야 클라이언트는 연결요청을 위해서 connect 함수를 호출할 수 있다.
이전에 connect 함수가 호출되면 오류 발생한다.
#include <sys/socket.h>
int listen(int sock, int backlog); // 성공 시 0, 실패 시 -1 반환
sock:연결요청 대기상태에 두고자 하는 소켓의 파일 디스크립터 전달, 이 함수의 인자로 전달된 디스크립터의 소켓이 서버 소켓이 된다.
backlog:연결요청 대기 Queue의 크기정보 전달, 5가 전달되면 큐의 크기가 5가 되어 클라이언트의 연결요청을 5개까지 대기시킬 수 있다.

서버가 연결요청 대기상태에 있다는 것은 클라이언트가 연결요청을 했을 때 연결이 수락될 때까지 연결요청 자체를 대기시킬 수 있는 상태에 있다.
클라이언트의 연결요청도 인터넷을 통해서 흘러 들어오는 일종의 데이터 전송이기 때문에 소켓이 하나 있어야 한다.
문지기역할을 한다고 할 수 있다.
클라이언트의 연결요청을 대기실로 안내한다.
이 대기실을 연결요청 대기 큐라한다.
서버 소켓과 연결요청 대기 큐가 완전히 준비되어서 클라이언트의 연결요청을 받아 들일 수 있는 상태를 연결요청 대기상태.
웹 서버와 같이 잦은 연결 요청을 받는 서버의 경우에는 최소 15이상을 전달해야 한다.

클라이언트의 연결요청 수락
들어온 순서대로 연결요청을 수락해야 한다.
수락한다는 것은 클라이언트와 데이터를 주고받을 수 있는 상태가 됨.
소켓이 필요한데 다음 함수의 호출결과로 소켓이 만들어지고, 자동으로 연결된다.
#include <sys/socket.h>
int accept(int sock, struct sockaddr* addr, socklen_t* addrlen); // 성공 시 생성된 소켓의 파일 디스크립터, 실행 시 -1 반환
sock:서버 소켓의 파일 디스크립터 전달.
addr:연결요청 한 클라이언트의 주소정보를 담을 변수의 주소 값 전달, 함수호출이 완료되면 인자로 전달된 주소의 변수에는 클라이언트의 주소정보가 채워진다.
addrlen:addr에 전달된 주소의 변수 크기를 바이트 단위로 전달, 단 크기정보를 변수에 저장한 다음에 변수의 주소 값을 전달한다.
그리고 함수호출이 완료되면 크기정보로 채워져 있던 변수에는 클라이언트의 주소정보 길이가 바이트 단위로 계산되어 채워진다.
accept 함수는 연결요청 대기 큐에서 대기중인 클라이언트의 연결요청을 수락하는 기능의 함수이다.
따라서 accept 함수는 호출성공 시 내부적으로 데이터 입출력에 사용할 소켓을 생성하고, 그 소켓의 파일디스크립터를 반환한다.
소켓이 자동으로 생성되어, 연결요청을 한 클라이언트 소켓에 연결까지 이뤄짐.

Hello world 서버 프로그램 리뷰
hello_server.c

TCP 클라이언트의 기본적인 함수호출 순서
socket() --------> connect() ----------> read()/write() -----------> close()
소켓 생성          연결요청               데이터 송수신              연결 종료
서버가 listen 함수를 호출한 이후부터 연결요청 대기 큐를 만들어 놓는다. 그 이후에 연결요청을 할 수 있다.
#include <sys/socket.h>
int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen); // 성공 시 0, 실패 시 -1 반환
sock:클라이언트 소켓의 파일 디스크립터 전달.
servaddr:연결요청 할 서버의 주소정보를 담은 변수의 주소 값 전달
addrlen:두 번째 매개변수 servaddr에 전달된 주소의 변수 크기를 바이트 단위로 전달. 크기정보를 변수에 저장한 다음에 변수의 주소 값을 전달한다.
그리고 함수호출이 완료되면 크기정보로 채워져 있던 변수에는 클라이언트의 주소정보 길이가 바이트 단위로 계산되어 채워진다.
connect 함수가 호출되면 서버에 의해 연결요청이 접수되거나 오류상황이 발생해 연결요청이 중단되어야 반환.
연결요청접수는 클라이언트의 연결요청 정보가 서버의 연결요청 대기 큐에 등록된 상황이다.
그래서 connect 함수가 반환해도 당장에 서비스가 이뤄지지 않을 수도 있다.

클라이언트 소켓의 주소정보는 어디에?
네트워크를 통해서 데이터를 송수신하려면 IP와 PORT가 반드시 할당되어야 한다.
connect 함수가 호출될 때 운영체제, 커널에서 IP는 호스트에 할당된 IP로, PORT는 임의로 선택해서 할당.
bind 함수를 통해 직접 할당하지 않아도 connet 함수호출 시 자동으로 소켓에 IP와 PORT가 할당.

Hello world 클라이언트 프로그램 리뷰
hello_client.c

TCP기반 서버, 클라이언트의 함수호출 관계
서버는 소켓 생성 이후에 bind, listen 함수의 연이은 호출을 통해 대기상태에 들어가고,
클라이언트는 connect 함수호출을 통해서 연결요청을 하게 된다. listen이후에 가능하다.
클라이언트가 connect 함수를 호출하기 전에 서버가 accept 함수를 먼저 호출할 수도 있다.
클라이언트가 connect 함수를 호출할 때까지 서버는 accept 함수가 호출된 위치에서 블로킹 상태에 놓이게 된다.

04-3 Iterative 기반의 서버, 클라이언트 구현
Iterative 서버의 구현
큐의 크기까지 설정해 놓았다면, 연결요청을 하는 모든 클라이언트에게 약속되어 있는 서비스를 제공해야 한다.
반복문을 삽입해서 accept 함수를 반복 호출하면 된다.
socet() -> bind() -> listen() -> accept() -> read()/write() -> close(client) -> close(server)
                              ↑-----------------------------------------------↓
close 함수까지 호출되었다면 한 클라이언트에 대한 서비스가 완료된 것.
또 다른 클라이언트에게 서비스하기 위해선 다시 accept 함수부터 호출해야 한다.
현재는 한 순간에 하나의 클라이언트에게만 서비스를 제공.

Iterative 에코 서버, 에코 클라이언트
1. 서버는 한 순간에 하나의 클라이언트와 연결되어 에코 서비스를 제공한다.
2. 서버는 총 다섯 개의 클라이언트에게 순차적으로 서비스를 제공하고 종료한다.
3. 클라이언트는 프로그램 사용자로부터 문자열 데이터를 입력 받아서 서버에 전송한다.
4. 서버는 전송 받은 문자열 데이터를 클라이언트에게 재전송한다. 에코시킨다.
5. 서버와 클라이언트간의 문자열 에코는 클라이언트가 Q를 입력할 때까지 계속한다.
echo_server.c
echo_client.c

에코 클라이언트의 문제점
read, write 함수가 호출될 때마다 문자열 단위로 실제 입출력이 이뤄진다는 잘못된 가정이 존재한다.
write 함수를 호출할 때마다 하나의 문장을 전송하지만 TCP는 데이터의 경계가 없다.
둘 이상의 write 함수호출로 전달된 문자열 정보가 묶어서 한번에 서버에 전송될 수도 있다.
길어서 두 개의 패킷에 나눠서 보낼 수도 있다.
송수신하는 데이터의 크기가 작고, 실제 실행환경이 가까워 오류가 발생하지 않은 것.

04-4 윈도우 기반으로 구현하기
윈도우 기반 에코 서버
1. WSAStartup, WSACleanup 함수호출을 통한 소켓 라이브러리의 초기화와 해제
2. 자료형과 변수의 이름을 윈도우 스타일로 변경하기
3. 데이터 송수신을 위해서 read, write 대신 recv, send 함수 호출하기
4. 소켓의 종료를 위해서 close 대신 closesocket 함수 호출하기
echo_server_win.c

윈도우 기반 에코 클라이언트




