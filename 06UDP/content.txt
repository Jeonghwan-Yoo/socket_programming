06-1 UDP에 대한 이해
데이터 송수신은 TCP 소켓을 생성해서 TCP방식으로 송수신 하는 방식    
데이터 송수신은 UDP 소켓을 생성해서 UDP방식으로 송수신 하는 방식    

UDP 소켓의 특성
편지에 보내는 사람과 받는 사람의 주소 정보를 써 넣지만 우체통에 넣어주면 끝.
상대방의 수신여부를 확인할 길은 없다.
UDP 소켓은 신뢰할 수 없는 전송방법을 제공한다.
UDP는 TCP보다 훨씬 간결한 구조로 설계
ACK, SEQ가 없어서 상황에 따라서 TCP보다 훨씬 좋은 성능을 발휘한다.
UDP는 TCP보다 구현이 용이하다.
그리고 생각보다 데이터의 손실이 자주 발생하는 것도 아니어서 신뢰성보다 성능이 중요시되는 상황에서는 UDP가 좋은 선택.
TCP는 신뢰성 없는 IP기반으로 신뢰성 있는 데이터의 송수신을 위해서 'Flow Control'를 하지만 UDP에서는 하지 않는다.
흐름제어가 구분 지어주는 가장 큰 차이점.
TCP의 생명은 흐름제어에 있다.
소켓과의 연결 및 종료 과정도 흐름제어의 일부분.
TCP가 UDP보다 빠를 순 없지만, 데이터의 성격에 따라 비슷한 속도를 내기도 한다.
한번에 송수신하는 데이터의 분량이 클수록 TCP는 UDP 못지않은 전송속도를 낸다.

UDP의 내부 동작원리
UDP의 가장 중요한 것은 호스트로 수신된 패킷을 PORT 정보를 참조하여 최종 목적지인 UDP 소켓에 전달하는 것.

UDP의 효울적 사용
UDP도 나름대로 상당히 신뢰할만하다.
1만개의 패킷을 보냈는데 그 중 1개만 손실되도 문제가 발생하는 압축파일의 경우에는 반드시 TCP.
일부만 손실되어도 압축의 해제가 어렵기 때문.
멀티미디어 데이터는 그 특성상 일부가 손실되어도 크게 문제되지 않는다.
화면 떨림이나 잡음은 넘어갈만하지만 실시간으로 서비스를 해야하므로 속도가 상당히 중요한 요소.
이러한 경우가 UDP기반의 구현.
TCP가 UDP에 비해 느린 이유
1. 데이터 송수신 이전, 이훙 거치는 연결설정 및 해제과정
2. 데이터 송수신 과정에서 거치는 신뢰성보장을 위한 흐름제어
송수신하는 데이터의 양은 작으면서 잦은 연결이 필요한 경우에는 UDP가 TCP보다 훨씬 효울적이고 빠르게 동작한다.

06-2 UDP 기반 서버/클라이언트의 구현
UDP에서의 서버와 클라이언트는 연결되어 있지 않습니다.
UDP 서버, 클라이언트는 연결된 상태로 데이터를 송수신하지 않는다.
연결 설정의 과정이 불필요하기에 listen, accept 함수의 호출은 불필요하다.
UDP 소켓의 생성과 데이터의 송수신 과정만 존재할 뿐.

UDP에서는 서버건 클라이언트건 하나의 소켓만 있으면 됩니다.
TCP에서는 소켓과 소켓의 관계가 일대일.
그러나 UDP는 하나의 소켓만 있으면 된다.
우체통을 UDP 소켓에 비유할 수 있다.
UDP 소켓이 하나 있으면 어디건 데이터를 전송할 수 있다.
UDP 소켓은 하나만 있으면 둘 이상의 호스트와의 통신이 가능하다.

UDP 기반의 데이터 입출력 함수
TCP에서 데이터를 전송할 때 주소 정보를 따로 추가하는 과정이 필요 없다.
목적지에 해당하는 소켓과 연결된 상태기 때문.
TCP 소켓은 목적지의 주소정보를 이미 알고 있는 상태다.
UDP 소켓은 연결상태를 유지하지 않으므로, 데이터를 전송할 때마다 반드시 목적지의 주소정보를 별도로 추가해야 한다.

#include <sys/socket.h>
ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr* to, socklen_t addrlen); // 성공 시 전송된 바이트 수, 실패 시 -1 반환.
sock:데이터 전송에 사용될 UDP 소켓의 파일 디스크립터를 인자로 전달.
buff:전송할 데이터를 저장하고 있는 버퍼의 주소 값 전달.
nbytes:전송할 데이터 크기를 바이트 단위로 전달.
flags:옵션 지정에 사용되는 매개변수, 지정할 옵션이 없다면 0 전달.
to:목적지 주소정보를 담고 있는 sockaddr 구조체 변수의 주소 값 전달.
addrlen:매개변수 to로 전달된 주소 값의 구조체 변수 크기 전달.
TCP 함수와 가장 비교되는 것은 목적지 주소정보를 요구하고 있다.

UDP데이터는 발신지가 일정치 않기 때문에 발신지 정보를 얻을 수 있도록 함수가 정의 되어있다.
UDP 패킷에 담겨 있는 발신지 정보를 함깨 반환한다.
#include <sys/socket.h>
ssize_t recvfrom(int sock, void* buff, size_t nbtes, int flags, struct sockaddr* from, socklen_t* addrlen); // 성공 시 수신한 바이트 수, 실패 시 -1 반환
sock:데이터 수신에 사용될 UDP 소켓의 파일 디스크립터를 인자로 전달.
buff:데이터 수신에 사용될 버퍼의 주소 값 전달.
nbytes:수신할 최대 바이트 수 전달, 때문에 매개변수 buff가 가리키는 버퍼의 크기를 넘을 수 없다.
flags:옵션 지정에 사용되는 매개변수, 지정할 옵션이 없다면 0 전달.
from:발신지 정보를 채워 넣을 sockaddr 구조체 변수의 주소 값 전달.
addrlen:매개변수 from으로 전달된 주소에 해당하는 구조체 변수의 크기 정보를 담고 있는 변수의 주소 값 전달.

UDP 기반의 에코 서버와 에코 클라이언트
서버 및 클라이언트라는 표현이 적절치 않은 부분도 있다.
uecho_server.c
uecho_client.c

UDP 클라이언트 소켓의 주소정보 할당
TCP 클라이언트의 경우에는 connect 함수호출 시 자동으로 할당되었다.
UDP 프로그램에서는 데이터를 전송하는 sendto 함수호출 이전에 해당 소켓에 주소정보가 할당되어 있어야 한다.
sendto 함수호출 잉전에 bind 함수를 호출해서 주소정보를 할당해야 한다.
bind는 TCP, UDP 모두 호출 가능.
snedto 함수호출 시까지 주소정보가 할당되지 않았다면, sendto 함수가 처음 호출되는 시점에 해당 소켓에 IP와 PORT번호가 자동으로 할당.
한번 할당되면 프로그램이 종료될 때까지 주소정보가 그대로 유지되기 때문에 다른 UDP 소켓과 데이터를 주고 받을 수 있다.
IP는 호스트의 IP, PORT는 사용하지 않는 PORT번호 하나를 임의로 골라서 할당하게 된다.
일반적으로 UDP의 클라이언트 프로그램에서는 주소정보를 할당하는 별도의 과정이 불필요하다.

06-3 UDP의 데이터 송수신 특성과 UDP에서의 connect 함수호출
UDP 기반에서 송수신하는 데이터에 경계가 존재한다.

데이터의 경계가 존재하는 UDP 소켓
UDP는 데이터 송수신 과정에서 호출하는 입출력함수의 호출횟수가 큰 의미를 지닌다.
입력함수의 호출횟수와 출력함수의 호출횟수가 완벽히 일치해야 송신된 데이터 전부를 수신할 수 있다.
bound_host1.c
bound_host2.c
recvfrom 함수가 호출되기 이전에 3회의 sendto 함수호출이 진행되어서, 데이터는 이미 전송된 상태에 놓이게 된다.
TCP라면 단 한번의 입력함수 호출을 통해서 모든 데이터를 읽어 들일 수 있다.
UDP는 3회의 recvfrom 함수호출이 요구된다.
그러므로 UDP 기반의 데이터 송수신과정에서는 입출력 함수의 호출횟수를 일치시켜야 한다.

UDP datagram
UDP 소켓이 전송하는 패킷을 가리켜 데이터그램이라고 표현. 데이터그램도 패킷의 일종.
TCP 패킷과 달리 데이터의 일부가 아닌, 그 자체가 하나의 데이터로 의미를 가질 때 데이터그램.
UDP는 데이터의 경계가 존재하기 때문에 하나의 패킷이 하나의 데이터로 간주된다.

connected UDP 소켓, unconnnected UDP 소켓
TCP 소켓에는 데이터를 전송할 IP와 PORT번호를 등록하지만, UDP 소켓에는 전송할 목적지의 IP와 PORT 번호를 등록하지 않는다.
sendto 함수호출을 통한 데이터의 전송과정
1. UDP 소켓에 목적지의 IP와 PORT 번호 등록
2. 데이터 전송
3. UDP 소켓에 등록된 목적지 정보 삭제
sendto 함수가 호출될 때마다 과정을 반복하게 된다.
목적지의 주소정보가 계속해서 변경되기 때문에 하나의 UDP 소켓을 이용해서 다양한 목적지로 데이터 전송이 가능한 것.
목적지 정보가 등록되어 있지 않은 소켓을 unconnected 소켓, 목적지 정보가 등록되어 있는 소켓을 connected 소켓.
UDP 소켓은 기본적으로 unconnected 소켓.
하나의 호스트와 오랜 시간 데이터를 송수신해야 한다면, UDP 소켓을 connected 소켓으로 만드는 것이 효율적이다.
주소를 등록하고 삭제하는 과정이 전송과정의 1/3에 해당하니, 이 시간을 줄임으로 성능향상을 기대할 수 있다.

connected UDP 소켓 생성
UDP 소켓을 대상으로 connect 함수만 호출해주면 된다.
sock = socket(PF_INET, SOCK_DGRAM, 0);
memset(&adr, 0, sizeof(adr));
adr.sin_family= AF_INET;
adr.sin_addr.s_addr = 
adr.sin_port = 
connect(sock, (struct sockaddr*)&adr, sizeof(adr));
UDP 소켓을 대상으로 connect 함수를 호출하면 UDP 소켓에 목적지의 IP와 PORT정보가 등록될 뿐.
TCP 소켓과 마찬가지로, sendto 함수가 호출될 때마다 데이터 전송의 과정만 거치게 된다.
뿐만 아니라 송수신의 대상이 정해졌기 때문에 write, read 함수의 호출로도 데이터를 송수신할 수 있다.

06-4 윈도우 기반으로 구현하기
#include <winsock2.h>
int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen); // 성공 시 전송된 바이트 수, 실패 시 SOCKET_ERROR 반환
#include <winsock2.h>
int recvfrom(SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen); // 성공 시 수신한 바이트 수, 실패 시 SOCKET_ERROR 반환
uecho_server_win.c
uecho_client_win.c